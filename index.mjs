import{isHex as t,hexToBn as e,BN as n,BN_ZERO as i}from"@polkadot/util";export{BN}from"@polkadot/util";import{ApiPromise as a,Keyring as s}from"@polkadot/api";import{WsProvider as r}from"@polkadot/rpc-provider/ws";import{options as o}from"@mangata-finance/types";import{XoShiRo256Plus as c}from"mangata-prng-xoshiro";import{encodeAddress as u}from"@polkadot/util-crypto";import g from"big.js";import{v4 as l}from"uuid";class d{static async getChain(t){return(await t.rpc.system.chain()).toHuman()}static async getNodeName(t){return(await t.rpc.system.name()).toHuman()}static async getNodeVersion(t){return(await t.rpc.system.version()).toHuman()}static async calculateRewardsAmount(i,a,s){const r=await i.rpc.xyk.calculate_rewards_amount(a,s);return t(r.price.toString())?e(r.price.toString()):new n(r.price)}static async calculateBuyPrice(t,e,i,a){const s=await t.rpc.xyk.calculate_buy_price(e,i,a);return new n(s.price)}static async calculateSellPrice(t,e,i,a){const s=await t.rpc.xyk.calculate_sell_price(e,i,a);return new n(s.price)}static async getBurnAmount(t,e,n,i){const a=await t.rpc.xyk.get_burn_amount(e,n,i);return JSON.parse(a.toString())}static async calculateSellPriceId(t,e,i,a){const s=await t.rpc.xyk.calculate_sell_price_id(e,i,a);return new n(s.price)}static async calculateBuyPriceId(t,e,i,a){const s=await t.rpc.xyk.calculate_buy_price_id(e,i,a);return new n(s.price)}}class w{static instance;db={};constructor(){}static getInstance(){return w.instance||(w.instance=new w),w.instance}hasAddressNonce=t=>!!this.db[t];setNonce=(t,e)=>{this.db[t]=e};getNonce=t=>this.db[t]}const y=w.getInstance(),m=async t=>(await t.query.assetsInfo.assetsInfo.entries()).reduce(((t,[e,n])=>{const i=n.toHuman(),a=e.toHuman()[0].replace(/[, ]/g,""),s={id:a,chainId:0,symbol:i.symbol,address:"MGA"===i.symbol?"0xc7e3bda797d2ceb740308ec40142ae235e08144a":"ETH"===i.symbol?"0x0000000000000000000000000000000000000000":i.description,name:i.symbol.includes("TKN")?"Liquidity Pool Token":i.name,decimals:Number(i.decimals)};return t[a]=s,t}),{}),p=async t=>(await t.query.xyk.liquidityAssets.entries()).reduce(((t,[e,n])=>{const i=e.args.map((t=>t.toHuman()))[0],a=n.toString().replace(/[, ]/g,"");return t[i]=a,t}),{}),h=async(i,a)=>(await i.query.tokens.accounts.entries(a)).reduce(((i,[a,s])=>{const r=JSON.parse(JSON.stringify(s)).free.toString(),o=JSON.parse(JSON.stringify(s)).frozen.toString(),c=JSON.parse(JSON.stringify(s)).reserved.toString(),u={free:t(r)?e(r):new n(r),frozen:t(o)?e(o):new n(o),reserved:t(c)?e(c):new n(c)};return i[a.toHuman()[1].replace(/[, ]/g,"")]=u,i}),{}),k=async t=>{const n=await m(t);return Object.values(n).filter((t=>"1"!==t.id&&"3"!==t.id)).reduce(((t,n)=>{const i={...n,symbol:n.symbol.includes("TKN")?n.symbol.split("-").reduce(((t,n)=>{const i=n.replace("TKN",""),a=i.startsWith("0x")?e(i).toString():i;return t.push(a),t}),[]).join("-"):n.symbol};return t[i.id]=i,t}),{})},I=new n("0"),f=new n("1"),A=new n("10"),S=new n("100"),T=new n("1000"),x=new n("10000"),B=new n("100000"),b=new n("1000000"),q=new n("10000000"),P=new n("100000000"),N=new n("1000000000"),F=new n("10000000000"),v=new n("100000000000"),L=new n("1000000000000"),R=18,O=new n("10").pow(new n(18)),C=async(t,e,i)=>{if(i.isZero())return I;const a=await t.query.tokens.totalIssuance(e),s=new n(a.toString());return i.mul(O).div(s)},$=(t,e)=>e.gt(I)?$(e,t.mod(e)):t,H=(t,e)=>{const n=((t,e)=>{const n=$(t,e);return n.isZero()?[I,I]:[t.div(n),e.div(n)]})(t,e);return n[1].mul(O).div(n[0])},E=async t=>{try{return(await t.query.issuance.promotedPoolsRewards.entries()).map((([t])=>t.args.map((t=>t.toHuman()))[0]))}catch(t){return[]}};class _{static async getNonce(t,e){return(await t.rpc.system.accountNextIndex(e)).toBn()}static async getAmountOfTokenIdInPool(i,a,s){const r=await i.query.xyk.pools([a,s]),o=r[0].toString(),c=r[1].toString();return[t(o)?e(o):new n(o),t(c)?e(c):new n(c)]}static async getLiquidityTokenId(t,e,a){const s=await t.query.xyk.liquidityAssets([e,a]);return s.isSome?new n(s.toString()):i}static async getLiquidityPool(t,e){const i=await t.query.xyk.liquidityPools(e);return i.isSome?i.unwrap().map((t=>new n(t))):[new n(-1),new n(-1)]}static async getTotalIssuance(t,e){const i=await t.query.tokens.totalIssuance(e);return new n(i)}static async getTokenBalance(i,a,s){const{free:r,reserved:o,frozen:c}=await i.query.tokens.accounts(a,s);return{free:t(r.toString())?e(r.toString()):new n(r.toString()),reserved:t(o.toString())?e(o.toString()):new n(o.toString()),frozen:t(c.toString())?e(c.toString()):new n(c.toString())}}static async getNextTokenId(t){const e=await t.query.tokens.nextCurrencyId();return new n(e)}static async getTokenInfo(t,e){return(await this.getAssetsInfo(t))[e]}static async getLiquidityTokenIds(t){return(await t.query.xyk.liquidityAssets.entries()).map((t=>t[1].toString()))}static async getLiquidityTokens(t){const e=await this.getAssetsInfo(t);return Object.values(e).reduce(((t,e)=>(e.name.includes("Liquidity Pool Token")&&(t[e.id]=e),t)),{})}static async getAssetsInfo(t){const n=await m(t);return Object.values(n).filter((t=>"1"!==t.id&&"3"!==t.id)).reduce(((t,i)=>{const a={...i,symbol:i.symbol.includes("TKN")?i.symbol.split("-").reduce(((t,i)=>{const a=i.replace("TKN",""),s=a.startsWith("0x")?e(a).toString():a,r=n[s].symbol;return t.push(r),t}),[]).join("-"):i.symbol};return t[a.id]=a,t}),{})}static async getBlockNumber(t){return(await t.rpc.chain.getBlock()).block.header.number.toString()}static async getOwnedTokens(t,e){if(!e)return null;const[n,i]=await Promise.all([this.getAssetsInfo(t),h(t,e)]);return Object.values(n).reduce(((t,e)=>(Object.keys(i).includes(e.id)&&(t[e.id]={...e,balance:i[e.id]}),t)),{})}static async getBalances(t){return(await t.query.tokens.totalIssuance.entries()).reduce(((t,[e,i])=>{const a=e.toHuman()[0].replace(/[, ]/g,""),s=new n(i.toString());return t[a]=s,t}),{})}static async getInvestedPools(t,e){const[n,i,a]=await Promise.all([k(t),h(t,e),E(t)]),s=Object.values(n).reduce(((t,e)=>(Object.keys(i).includes(e.id)&&e.name.includes("Liquidity Pool Token")&&t.push(e),t)),[]).map((async e=>{const n=i[e.id],s=e.symbol.split("-")[0],r=e.symbol.split("-")[1],[o,c]=await this.getAmountOfTokenIdInPool(t,s.toString(),r.toString());return{firstTokenId:s,secondTokenId:r,firstTokenAmount:o,secondTokenAmount:c,liquidityTokenId:e.id,isPromoted:a.includes(e.id),share:await C(t,e.id,n.free.add(n.reserved)),firstTokenRatio:H(o,c),secondTokenRatio:H(c,o),activatedLPTokens:n.reserved,nonActivatedLPTokens:n.free}}));return Promise.all(s)}static async getPool(t,e){const[n,i]=await Promise.all([this.getLiquidityPool(t,e),t.query.issuance.promotedPoolsRewards(e)]),[a,s]=n,[r,o]=await this.getAmountOfTokenIdInPool(t,a.toString(),s.toString());return{firstTokenId:a.toString(),secondTokenId:s.toString(),firstTokenAmount:r,secondTokenAmount:o,liquidityTokenId:e,isPromoted:i.gtn(0),firstTokenRatio:H(r,o),secondTokenRatio:H(o,r)}}static async getPools(i){const[a,s]=await Promise.all([k(i),p(i)]),r=await(async(i,a)=>(await i.query.xyk.pools.entries()).reduce(((i,[s,r])=>{const o=s.args.map((t=>t.toHuman()))[0],c=JSON.parse(JSON.stringify(r)).map((i=>t(i)?e(i):new n(i)));return i[a[o]]=c,i}),{}))(i,s),o=await E(i);return Object.values(a).reduce(((t,e)=>Object.values(s).includes(e.id)?t.concat(e):t),[]).map((t=>{const[e,n]=r[t.id];return{firstTokenId:t.symbol.split("-")[0],secondTokenId:t.symbol.split("-")[1],firstTokenAmount:e,secondTokenAmount:n,liquidityTokenId:t.id,firstTokenRatio:H(e,n),secondTokenRatio:H(n,e),isPromoted:o.includes(t.id)}}))}}function M(t){const{s0:e,s1:n,s2:i,s3:a}=function(t){return{s0:BigInt(t[0])<<BigInt(0)|BigInt(t[1])<<BigInt(8)|BigInt(t[2])<<BigInt(16)|BigInt(t[3])<<BigInt(24)|BigInt(t[4])<<BigInt(32)|BigInt(t[5])<<BigInt(40)|BigInt(t[6])<<BigInt(48)|BigInt(t[7])<<BigInt(56),s1:BigInt(t[8])<<BigInt(0)|BigInt(t[9])<<BigInt(8)|BigInt(t[10])<<BigInt(16)|BigInt(t[11])<<BigInt(24)|BigInt(t[12])<<BigInt(32)|BigInt(t[13])<<BigInt(40)|BigInt(t[14])<<BigInt(48)|BigInt(t[15])<<BigInt(56),s2:BigInt(t[16])<<BigInt(0)|BigInt(t[17])<<BigInt(8)|BigInt(t[18])<<BigInt(16)|BigInt(t[19])<<BigInt(24)|BigInt(t[20])<<BigInt(32)|BigInt(t[21])<<BigInt(40)|BigInt(t[22])<<BigInt(48)|BigInt(t[23])<<BigInt(56),s3:BigInt(t[24])<<BigInt(0)|BigInt(t[25])<<BigInt(8)|BigInt(t[26])<<BigInt(16)|BigInt(t[27])<<BigInt(24)|BigInt(t[28])<<BigInt(32)|BigInt(t[29])<<BigInt(40)|BigInt(t[30])<<BigInt(48)|BigInt(t[31])<<BigInt(56)}}(t);return new c(e,n,i,a)}class K{xoshiro;constructor(t){this.xoshiro=M(t)}next_u64(){const t=new n(this.xoshiro.nextBigInt(BigInt(4294967295)).toString()),e=new n(this.xoshiro.nextBigInt(BigInt(4294967295)).toString());return t.shln(32).or(e)}shuffle=t=>{for(let e=t.length-1;e>0;e--){const n=this.next_u64().modn(e+1),i=t[e];t[e]=t[n],t[n]=i}}}const j=t=>{if(!t)return"";const e=t.length;return t.substring(0,7)+"..."+t.substring(e-5,e)};const U=async(t,e,n,i)=>new Promise((async(a,s)=>{let r=[];const o="string"==typeof n?n:n.address,c=await(async(t,e,n)=>{let i;if(n&&n.nonce)i=n.nonce;else{const n=await _.getNonce(t,e);i=y.hasAddressNonce(e)?y.getNonce(e):n,n&&n.gt(i)&&(i=n);const a=i.addn(1);y.setNonce(e,a)}return i})(t,o,i);let u=0;try{const g=await e.signAndSend(n,{nonce:c,signer:i?.signer},(async n=>{if(console.info(`Tx[${j(e.hash.toString())}] => ${n.status.type}(${n.status.value.toString()})${function(t,e){if(!process.env.TX_VERBOSE)return"";const n=JSON.parse(e.method.toString()),i=JSON.stringify(n.args),a=t.registry.findMetaCall(e.method.callIndex);if("sudo"==a.method&&"sudo"==a.method){const i=e.method.args[0].callIndex,a=JSON.stringify(n.args.call.args),s=t.registry.findMetaCall(i);return` (sudo::${s.section}::${s.method}(${a})`}return` (${a.section}::${a.method}(${i}))`}(t,e)}`),i?.statusCallback?.(n),n.status.isFinalized){const c=n.status.asFinalized.toString(),l=(await t.rpc.chain.getHeader(c)).number.toBn(),d=l.addn(1),w=await t.rpc.chain.subscribeFinalizedHeads((async n=>{if(n.number.toBn().gt(l)){const n=await t.rpc.chain.getBlockHash(d),o=await t.rpc.chain.getHeader(n);w();const u=(await t.rpc.chain.getBlock(o.hash)).block.extrinsics,l=await t.query.system.events.at(o.hash),y=JSON.parse(o.toString()),m=Buffer.from(y.seed.seed.substring(2),"hex"),p=y.count,h=u.slice(0,p).filter((t=>!t.isSigned)),k=u.slice(p,u.length),I=h.concat(k),f=I.filter((t=>!t.isSigned)),A=((t,e)=>{let n=[];const i=new K(e),a=new Map;for(t.forEach((t=>{const e=t[0],n=t[1];a.has(e)?a.get(e).push(n):a.set(e,[n])}));0!=a.size;){const t=[],e=[];for(const t of a.entries())e.push(t[0]);e.sort();for(const n of e){const e=a.get(n);t.push(e.shift()),0==e.length&&a.delete(n)}i.shuffle(t),n=n.concat(t)}return n})(I.filter((t=>t.isSigned)).map((t=>[t.isSigned?t.signer.toString():"0000",t])),Uint8Array.from(m)),S=f.concat(A),T=S.findIndex((t=>t.hash.toString()===e.hash.toString()));T<0&&(I.forEach((t=>{console.info(`Tx ([${j(e.hash.toString())}]) origin ${t.hash.toString()}`)})),S.forEach((t=>{console.info(`Tx ([${j(e.hash.toString())}]) shuffled ${t.hash.toString()}`)})),s(`Tx ([${e.hash.toString()}])\n                      could not be find in a block\n                      $([${j(c)}])`));const x=l.filter((t=>t.phase.isApplyExtrinsic&&t.phase.asApplyExtrinsic.toNumber()===T)).map((e=>{const{event:n,phase:i}=e,a=n.typeDef,s=n.data.map(((t,e)=>({lookupName:a[e].lookupName,data:t})));return{event:n,phase:i,section:n.section,method:n.method,metaDocumentation:n.meta.docs.toString(),eventData:s,error:J(t,n.method,s)}}));r=r.concat(x),i?.extrinsicStatus?.(r),a(r),g()}else if(u++<10)console.info(`Retry [${u}] Tx: [${j(e.hash.toString())}] current: #${n.number} [${j(n.hash.toString())}] finalized in: #${l} [${j(c)}] `);else{w(),s(`Transaction was not finalized: Tx ([${j(e.hash.toString())}]): parent hash: ([${j(n.parentHash.toString())}]): Status finalized: ([${j(c)}])`);const i=await _.getNonce(t,o);y.setNonce(o,i),g()}}))}else if(n.isError){s(`Tx ([${j(e.hash.toString())}]) Transaction error`);const n=await _.getNonce(t,o);y.setNonce(o,n)}}))}catch(e){const n=await _.getNonce(t,o);y.setNonce(o,n),s({data:e.message||e.description||e.data?.toString()||e.toString()})}})),J=(t,e,i)=>{if("ExtrinsicFailed"===e){const e=i.find((t=>t.lookupName.includes("DispatchError")))?.data?.toHuman?.(),a=e?.Module?.error,s=e?.Module?.index;if(!a||!s)return{documentation:["Unknown error"],name:"UnknownError"};try{const e=t.registry.findMetaError({error:new n(a),index:new n(s)});return{documentation:e.docs,name:e.name}}catch(t){return{documentation:["Unknown error"],name:"UnknownError"}}}return null};class V{static async sendKusamaTokenFromRelayToParachain(t,e,n,i,s,o){const c=new r(t),u=await new a({provider:c}).isReady,g={V1:{interior:{X1:{ParaChain:s}},parents:0}},l={V1:{interior:{X1:{AccountId32:{id:u.createType("AccountId32",n).toHex(),network:"Any"}}},parents:0}},d={V1:[{fun:{Fungible:i},id:{Concrete:{interior:"Here",parents:0}}}]};await u.tx.xcmPallet.reserveTransferAssets(g,l,d,0).signAndSend(e,{signer:o?.signer,nonce:o?.nonce})}static async sendKusamaTokenFromParachainToRelay(t,e,i,a,s){const r={V1:{parents:1,interior:{X1:{AccountId32:{network:"Any",id:t.createType("AccountId32",i).toHex()}}}}};await t.tx.xTokens.transfer("4",a,r,new n("6000000000")).signAndSend(e,{signer:s?.signer,nonce:s?.nonce})}static async activateLiquidity(t,e,n,i,a){return await U(t,t.tx.xyk.activateLiquidity(n,i),e,a)}static async deactivateLiquidity(t,e,n,i,a){return await U(t,t.tx.xyk.deactivateLiquidity(n,i),e,a)}static async claimRewards(t,e,n,i,a){return await U(t,t.tx.xyk.claimRewards(n,i),e,a)}static async createPool(t,e,n,i,a,s,r){return await U(t,t.tx.xyk.createPool(n,i,a,s),e,r)}static async sellAsset(t,e,n,i,a,s,r){return await U(t,t.tx.xyk.sellAsset(n,i,a,s),e,r)}static async buyAsset(t,e,n,i,a,s,r){return await U(t,t.tx.xyk.buyAsset(n,i,a,s),e,r)}static async mintLiquidity(t,e,n,i,a,s,r){return await U(t,t.tx.xyk.mintLiquidity(n,i,a,s),e,r)}static async burnLiquidity(t,e,n,i,a,s){return await U(t,t.tx.xyk.burnLiquidity(n,i,a),e,s)}static async transferToken(t,e,n,i,a,s){return await U(t,t.tx.tokens.transfer(i,n,a),e,s)}static async transferAllToken(t,e,n,i,a){return await U(t,t.tx.tokens.transferAll(i,n,!0),e,a)}}const z=g("0"),X=g("1"),D=g("10"),W=g("100"),Z=g("1000"),G=g("10000"),Q=g("100000"),Y=g("1000000"),tt=g("10000000"),et=g("100000000"),nt=g("1000000000"),it=g("10000000000"),at=g("100000000000"),st=g("1000000000000");g.PE=256,g.NE=-256,g.DP=40,g.RM=g.roundUp;const rt=D.pow(18),ot=(t,e)=>{if(!t)return I;try{const i=g(t),a=e&&18!==e?D.pow(e):rt,s=i.mul(a).toString();return/\D/gm.test(s)?I:new n(s)}catch(t){return I}},ct=(t,e)=>{if(!t)return"0";try{const n=g(t.toString()),i=e&&18!==e?D.pow(e):rt,a=n.div(i);return a.toString()}catch(t){return"0"}};class ut{static async sendKusamaTokenFromRelayToParachainFee(t,e,i,s,o){const c=new r(t),g=await new a({provider:c}).isReady,l={V1:{interior:{X1:{ParaChain:o}},parents:0}},d={V1:{interior:{X1:{AccountId32:{id:g.createType("AccountId32",u(i,42)).toHex(),network:"Any"}}},parents:0}},w={V1:[{fun:{Fungible:s},id:{Concrete:{interior:"Here",parents:0}}}]},y=await g.tx.xcmPallet.reserveTransferAssets(l,d,w,0).paymentInfo(e);return ct(new n(y.partialFee.toString()),12)}static async sendKusamaTokenFromParachainToRelayFee(t,e,i,a){const s={V1:{parents:1,interior:{X1:{AccountId32:{network:"Any",id:t.createType("AccountId32",u(i,2)).toHex()}}}}},r=await t.tx.xTokens.transfer("4",a,s,new n("6000000000")).paymentInfo(e);return ct(new n(r.partialFee.toString()))}static async activateLiquidity(t,e,i,a){const s=await t.tx.xyk.activateLiquidity(i,a).paymentInfo(e);return ct(new n(s.partialFee.toString()))}static async deactivateLiquidity(t,e,i,a){const s=await t.tx.xyk.deactivateLiquidity(i,a).paymentInfo(e);return ct(new n(s.partialFee.toString()))}static async claimRewardsFee(t,e,i,a){const s=await t.tx.xyk.claimRewards(i,a).paymentInfo(e);return ct(new n(s.partialFee.toString()))}static async createPoolFee(t,e,i,a,s,r){const o=await t.tx.xyk.createPool(i,a,s,r).paymentInfo(e);return ct(new n(o.partialFee.toString()))}static async sellAssetFee(t,e,i,a,s,r){const o=await t.tx.xyk.sellAsset(i,a,s,r).paymentInfo(e);return ct(new n(o.partialFee.toString()))}static async buyAssetFee(t,e,i,a,s,r){const o=await t.tx.xyk.buyAsset(i,a,s,r).paymentInfo(e);return ct(new n(o.partialFee.toString()))}static async mintLiquidityFee(t,e,i,a,s,r=new n(Number.MAX_SAFE_INTEGER)){const o=await t.tx.xyk.mintLiquidity(i,a,s,r).paymentInfo(e);return ct(new n(o.partialFee.toString()))}static async burnLiquidityFee(t,e,i,a,s){const r=await t.tx.xyk.burnLiquidity(i,a,s).paymentInfo(e);return ct(new n(r.partialFee.toString()))}static async transferTokenFee(t,e,i,a,s){const r=await t.tx.tokens.transfer(a,i,s).paymentInfo(e);return ct(new n(r.partialFee.toString()))}static async transferAllTokenFee(t,e,i,a){const s=await t.tx.tokens.transferAll(a,i,!0).paymentInfo(e);return ct(new n(s.partialFee.toString()))}}const gt=(t,e,i,a,s)=>{const r=e.sub(i),o=new n(t).mul(r),c=new n(s).mul(new n(106)).div(new n(6)),u=g(1e4),l=g(1.06).pow(r.toNumber()).mul(u).round(0,0),d=(""+l.toString()).replace(/(-?)(\d*)\.?(\d+)e([+-]\d+)/,(function(t,e,n,i,a){return a<0?e+"0."+Array(1-a-n.length).join("0")+n+i:e+n+i+Array(a-i.length+1).join("0")}));const w=new n(c).sub(new n(c).mul(new n(u.toString())).div(new n(d))),y=new n(o).sub(w);return new n(a).add(y)},lt=async(t,e,i,a,s)=>{const{lastCheckpoint:r,cummulativeWorkInLastCheckpoint:o,missingAtLastCheckpoint:c}=await(async(t,e,i,a)=>{const[s,r,o]=await a.query.xyk.liquidityMiningUser([t,e]);return new n(s.toString()).eq(new n(0))&&new n(r.toString()).eq(new n(0))&&new n(o.toString()).eq(new n(0))?{lastCheckpoint:i,cummulativeWorkInLastCheckpoint:g(0),missingAtLastCheckpoint:g(0)}:{lastCheckpoint:g(s.toString()),cummulativeWorkInLastCheckpoint:g(r.toString()),missingAtLastCheckpoint:g(o.toString())}})(t,i,a,s);return gt(e,a,new n(r.toString()),new n(o.toString()),new n(c.toString()))},dt=async(t,e,i,a)=>{const{lastCheckpoint:s,cummulativeWorkInLastCheckpoint:r,missingAtLastCheckpoint:o}=await(async(t,e,i)=>{const[a,s,r]=await i.query.xyk.liquidityMiningPool(t);return new n(a.toString()).eq(new n(0))&&new n(s.toString()).eq(new n(0))&&new n(r.toString()).eq(new n(0))?{lastCheckpoint:e,cummulativeWorkInLastCheckpoint:new n(0),missingAtLastCheckpoint:new n(0)}:{lastCheckpoint:new n(a.toString()),cummulativeWorkInLastCheckpoint:new n(s.toString()),missingAtLastCheckpoint:new n(r.toString())}})(e,i,a);return gt(t,i,new n(s.toString()),new n(r.toString()),new n(o.toString()))};class wt{api;urls;static instanceMap=new Map;constructor(t){this.urls=t,this.api=(async()=>await this.connectToNode(t))()}async connectToNode(t){const e=new r(t,5e3);return await a.create(o({provider:e,throwOnConnect:!0,throwOnUnknown:!0}))}static getInstance(t){return wt.instanceMap.has(t)||this.instanceMap.set(t,new wt(t)),this.instanceMap.get(t)}async getApi(){return this.api||(this.api=this.connectToNode(this.urls)),this.api}getUrls(){return this.urls}async waitForNewBlock(t){let e=0;const n=await this.getApi(),i=t||2;return new Promise((async t=>{const a=await n.rpc.chain.subscribeNewHeads((()=>{++e===i&&(a(),t(!0))}))}))}async getChain(){const t=await this.getApi();return d.getChain(t)}async getNodeName(){const t=await this.getApi();return d.getNodeName(t)}async getNodeVersion(){const t=await this.getApi();return d.getNodeVersion(t)}async getNonce(t){const e=await this.getApi();return _.getNonce(e,t)}async disconnect(){const t=await this.getApi();await t.disconnect()}async sendKusamaTokenFromRelayToParachain(t,e,n,i,a=2110,s){return await V.sendKusamaTokenFromRelayToParachain(t,e,n,i,a,s)}async sendKusamaTokenFromRelayToParachainFee(t,e,n,i,a=2110){return await ut.sendKusamaTokenFromRelayToParachainFee(t,e,n,i,a)}async sendKusamaTokenFromParachainToRelay(t,e,n,i){const a=await this.getApi();return await V.sendKusamaTokenFromParachainToRelay(a,t,e,n,i)}async sendKusamaTokenFromParachainToRelayFee(t,e,n){const i=await this.getApi();return await ut.sendKusamaTokenFromParachainToRelayFee(i,t,e,n)}async activateLiquidity(t,e,n,i){const a=await this.getApi();return await V.activateLiquidity(a,t,e,n,i)}async deactivateLiquidity(t,e,n,i){const a=await this.getApi();return await V.deactivateLiquidity(a,t,e,n,i)}async calculateFutureRewardsAmount(t,e,i){const a=await this.getApi();return await(async(t,e,i,a)=>{const s=await t.rpc.chain.getBlock(),r=new n(s.block.header.number.toString()),o=r.add(new n(a)).div(new n(1e4)),c=await t.query.xyk.liquidityMiningActiveUser([e,new n(i)]),u=await t.query.xyk.liquidityMiningActivePool(new n(i)),g=await lt(e,new n(c.toString()),i,o,t),l=await dt(new n(u.toString()),i,o,t),d=await t.query.xyk.liquidityMiningUserToBeClaimed([e,i]),w=await t.query.xyk.liquidityMiningUserClaimed([e,i]),y=await t.query.issuance.promotedPoolsRewards(i),m=new n(y.toString()),p=new n("136986000000000000000000"),h=a.sub(r).div(new n(1200)),k=await t.query.issuance.promotedPoolsRewards.entries(),I=m.add(p.mul(h).div(new n(k.length)));let f=new n(0);return g.gt(new n(0))&&l.gt(new n(0))&&(f=I.mul(g).div(l)),f.add(new n(d.toString())).sub(new n(w.toString()))})(a,t,e,i)}async calculateRewardsAmount(t,e){const n=await this.getApi();return await d.calculateRewardsAmount(n,t,e)}async claimRewardsFee(t,e,n){const i=await this.getApi();return await ut.claimRewardsFee(i,t,e,n)}async claimRewards(t,e,n,i){const a=await this.getApi();return await V.claimRewards(a,t,e,n,i)}async createPoolFee(t,e,n,i,a){const s=await this.getApi();return await ut.createPoolFee(s,t,e,n,i,a)}async createPool(t,e,n,i,a,s){const r=await this.getApi();return await V.createPool(r,t,e,n,i,a,s)}async sellAssetFee(t,e,n,i,a){const s=await this.getApi();return await ut.sellAssetFee(s,t,e,n,i,a)}async sellAsset(t,e,n,i,a,s){const r=await this.getApi();return await V.sellAsset(r,t,e,n,i,a,s)}async mintLiquidityFee(t,e,n,i,a){const s=await this.getApi();return await ut.mintLiquidityFee(s,t,e,n,i,a)}async mintLiquidity(t,e,n,i,a,s){const r=await this.getApi();return await V.mintLiquidity(r,t,e,n,i,a,s)}async burnLiquidityFee(t,e,n,i){const a=await this.getApi();return await ut.burnLiquidityFee(a,t,e,n,i)}async burnLiquidity(t,e,n,i,a){const s=await this.getApi();return await V.burnLiquidity(s,t,e,n,i,a)}async buyAssetFee(t,e,n,i,a){const s=await this.getApi();return await ut.buyAssetFee(s,t,e,n,i,a)}async buyAsset(t,e,n,i,a,s){const r=await this.getApi();return await V.buyAsset(r,t,e,n,i,a,s)}async calculateBuyPrice(t,e,n){const i=await this.getApi();return await d.calculateBuyPrice(i,t,e,n)}async calculateSellPrice(t,e,n){const i=await this.getApi();return await d.calculateSellPrice(i,t,e,n)}async getBurnAmount(t,e,n){const i=await this.getApi();return await d.getBurnAmount(i,t,e,n)}async calculateSellPriceId(t,e,n){const i=await this.getApi();return await d.calculateSellPriceId(i,t,e,n)}async calculateBuyPriceId(t,e,n){const i=await this.getApi();return await d.calculateBuyPriceId(i,t,e,n)}async getAmountOfTokenIdInPool(t,e){const n=await this.getApi();return await _.getAmountOfTokenIdInPool(n,t,e)}async getLiquidityTokenId(t,e){const n=await this.getApi();return await _.getLiquidityTokenId(n,t,e)}async getLiquidityPool(t){const e=await this.getApi();return await _.getLiquidityPool(e,t)}async transferTokenFee(t,e,n,i){const a=await this.getApi();return await ut.transferTokenFee(a,t,e,n,i)}async transferToken(t,e,n,i,a){const s=await this.getApi();return await V.transferToken(s,t,e,n,i,a)}async transferTokenAllFee(t,e,n){const i=await this.getApi();return await ut.transferAllTokenFee(i,t,e,n)}async transferTokenAll(t,e,n,i){const a=await this.getApi();return await V.transferAllToken(a,t,e,n,i)}async getTotalIssuance(t){const e=await this.getApi();return await _.getTotalIssuance(e,t)}async getTokenBalance(t,e){const n=await this.getApi();return await _.getTokenBalance(n,e,t)}async getNextTokenId(){const t=await this.getApi();return await _.getNextTokenId(t)}async getTokenInfo(t){const e=await this.getApi();return await _.getTokenInfo(e,t)}async getBlockNumber(){const t=await this.getApi();return await _.getBlockNumber(t)}async getOwnedTokens(t){const e=await this.getApi();return await _.getOwnedTokens(e,t)}async getLiquidityTokenIds(){const t=await this.getApi();return await _.getLiquidityTokenIds(t)}async getAssetsInfo(){const t=await this.getApi();return await _.getAssetsInfo(t)}async getBalances(){const t=await this.getApi();return await _.getBalances(t)}async getLiquidityTokens(){const t=await this.getApi();return await _.getLiquidityTokens(t)}async getPool(t){const e=await this.getApi();return await _.getPool(e,t)}async getInvestedPools(t){const e=await this.getApi();return await _.getInvestedPools(e,t)}async getPools(){const t=await this.getApi();return await _.getPools(t)}}const yt=(t,e)=>{const n=new RegExp(`^-?\\d+(?:\\.\\d{0,${e}})?`,"gm");return(t.match(n)?.[0]||t).match(/^0*(\d+(?:\.(?:(?!0+$)\d)+)?)/gm)?.[0]??t},mt=t=>{const e=+t;return!(!t||isNaN(Number(t))||isNaN(e)||e<0)};class pt{static createKeyring(t){return new s({type:t})}static createKeyPairFromName(t,e=""){const n=e||"//testUser_"+l(),i=t.createFromUri(n);return t.addPair(i),i}static getXoshiro(t){return M(t)}static getPriceImpact(t,e,n,i){if(!(t&&e&&mt(n)&&mt(i)))return;const a=t.firstTokenBalance,s=t.secondTokenBalance,r=ot(n,e.firstTokenDecimals),o=ot(i,e.secondTokenDecimals);if(o.gte(s))return"";const c=a.add(r).mul(x).mul(s),u=s.sub(o).mul(a),l=c.div(u).sub(x).toString(),d=g(l);return yt(d.div(W).toString(),2)}}export{nt as BIG_BILLION,W as BIG_HUNDRED,at as BIG_HUNDRED_BILLIONS,et as BIG_HUNDRED_MILLIONS,Q as BIG_HUNDRED_THOUSAND,Y as BIG_MILLION,X as BIG_ONE,D as BIG_TEN,it as BIG_TEN_BILLIONS,tt as BIG_TEN_MILLIONS,G as BIG_TEN_THOUSAND,Z as BIG_THOUSAND,st as BIG_TRILLION,z as BIG_ZERO,N as BN_BILLION,O as BN_DIV_NUMERATOR_MULTIPLIER,R as BN_DIV_NUMERATOR_MULTIPLIER_DECIMALS,S as BN_HUNDRED,v as BN_HUNDRED_BILLIONS,P as BN_HUNDRED_MILLIONS,B as BN_HUNDRED_THOUSAND,b as BN_MILLION,f as BN_ONE,A as BN_TEN,F as BN_TEN_BILLIONS,q as BN_TEN_MILLIONS,x as BN_TEN_THOUSAND,T as BN_THOUSAND,L as BN_TRILLION,I as BN_ZERO,wt as Mangata,pt as MangataHelpers,ct as fromBN,U as signTx,ot as toBN,yt as toFixed};
