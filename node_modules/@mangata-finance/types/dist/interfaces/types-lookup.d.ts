import '@polkadot/types/lookup';
import type { BTreeMap, BTreeSet, Bytes, Compact, Enum, Null, Option, Result, Struct, Text, U256, U8aFixed, Vec, bool, u128, u16, u32, u64, u8 } from '@polkadot/types-codec';
import type { ITuple } from '@polkadot/types-codec/types';
import type { AccountId32, Call, H256, H512, MultiAddress, Perbill, Permill } from '@polkadot/types/interfaces/runtime';
import type { Event } from '@polkadot/types/interfaces/system';
declare module '@polkadot/types/lookup' {
    /** @name FrameSystemAccountInfo (3) */
    interface FrameSystemAccountInfo extends Struct {
        readonly nonce: u32;
        readonly consumers: u32;
        readonly providers: u32;
        readonly sufficients: u32;
        readonly data: Null;
    }
    /** @name FrameSupportDispatchPerDispatchClassWeight (6) */
    interface FrameSupportDispatchPerDispatchClassWeight extends Struct {
        readonly normal: SpWeightsWeightV2Weight;
        readonly operational: SpWeightsWeightV2Weight;
        readonly mandatory: SpWeightsWeightV2Weight;
    }
    /** @name SpWeightsWeightV2Weight (7) */
    interface SpWeightsWeightV2Weight extends Struct {
        readonly refTime: Compact<u64>;
        readonly proofSize: Compact<u64>;
    }
    /** @name SpRuntimeDigest (20) */
    interface SpRuntimeDigest extends Struct {
        readonly logs: Vec<SpRuntimeDigestDigestItem>;
    }
    /** @name SpRuntimeDigestDigestItem (22) */
    interface SpRuntimeDigestDigestItem extends Enum {
        readonly isOther: boolean;
        readonly asOther: Bytes;
        readonly isConsensus: boolean;
        readonly asConsensus: ITuple<[U8aFixed, Bytes]>;
        readonly isSeal: boolean;
        readonly asSeal: ITuple<[U8aFixed, Bytes]>;
        readonly isPreRuntime: boolean;
        readonly asPreRuntime: ITuple<[U8aFixed, Bytes]>;
        readonly isRuntimeEnvironmentUpdated: boolean;
        readonly type: 'Other' | 'Consensus' | 'Seal' | 'PreRuntime' | 'RuntimeEnvironmentUpdated';
    }
    /** @name FrameSystemEventRecord (25) */
    interface FrameSystemEventRecord extends Struct {
        readonly phase: FrameSystemPhase;
        readonly event: Event;
        readonly topics: Vec<H256>;
    }
    /** @name FrameSystemEvent (27) */
    interface FrameSystemEvent extends Enum {
        readonly isExtrinsicSuccess: boolean;
        readonly asExtrinsicSuccess: {
            readonly dispatchInfo: FrameSupportDispatchDispatchInfo;
        } & Struct;
        readonly isExtrinsicFailed: boolean;
        readonly asExtrinsicFailed: {
            readonly dispatchError: SpRuntimeDispatchError;
            readonly dispatchInfo: FrameSupportDispatchDispatchInfo;
        } & Struct;
        readonly isCodeUpdated: boolean;
        readonly isNewAccount: boolean;
        readonly asNewAccount: {
            readonly account: AccountId32;
        } & Struct;
        readonly isKilledAccount: boolean;
        readonly asKilledAccount: {
            readonly account: AccountId32;
        } & Struct;
        readonly isRemarked: boolean;
        readonly asRemarked: {
            readonly sender: AccountId32;
            readonly hash_: H256;
        } & Struct;
        readonly isTxsEnqueued: boolean;
        readonly asTxsEnqueued: {
            readonly count: u64;
        } & Struct;
        readonly type: 'ExtrinsicSuccess' | 'ExtrinsicFailed' | 'CodeUpdated' | 'NewAccount' | 'KilledAccount' | 'Remarked' | 'TxsEnqueued';
    }
    /** @name FrameSupportDispatchDispatchInfo (28) */
    interface FrameSupportDispatchDispatchInfo extends Struct {
        readonly weight: SpWeightsWeightV2Weight;
        readonly class: FrameSupportDispatchDispatchClass;
        readonly paysFee: FrameSupportDispatchPays;
    }
    /** @name FrameSupportDispatchDispatchClass (29) */
    interface FrameSupportDispatchDispatchClass extends Enum {
        readonly isNormal: boolean;
        readonly isOperational: boolean;
        readonly isMandatory: boolean;
        readonly type: 'Normal' | 'Operational' | 'Mandatory';
    }
    /** @name FrameSupportDispatchPays (30) */
    interface FrameSupportDispatchPays extends Enum {
        readonly isYes: boolean;
        readonly isNo: boolean;
        readonly type: 'Yes' | 'No';
    }
    /** @name SpRuntimeDispatchError (31) */
    interface SpRuntimeDispatchError extends Enum {
        readonly isOther: boolean;
        readonly isCannotLookup: boolean;
        readonly isBadOrigin: boolean;
        readonly isModule: boolean;
        readonly asModule: SpRuntimeModuleError;
        readonly isConsumerRemaining: boolean;
        readonly isNoProviders: boolean;
        readonly isTooManyConsumers: boolean;
        readonly isToken: boolean;
        readonly asToken: SpRuntimeTokenError;
        readonly isArithmetic: boolean;
        readonly asArithmetic: SpRuntimeArithmeticError;
        readonly isTransactional: boolean;
        readonly asTransactional: SpRuntimeTransactionalError;
        readonly isExhausted: boolean;
        readonly isCorruption: boolean;
        readonly isUnavailable: boolean;
        readonly type: 'Other' | 'CannotLookup' | 'BadOrigin' | 'Module' | 'ConsumerRemaining' | 'NoProviders' | 'TooManyConsumers' | 'Token' | 'Arithmetic' | 'Transactional' | 'Exhausted' | 'Corruption' | 'Unavailable';
    }
    /** @name SpRuntimeModuleError (32) */
    interface SpRuntimeModuleError extends Struct {
        readonly index: u8;
        readonly error: U8aFixed;
    }
    /** @name SpRuntimeTokenError (33) */
    interface SpRuntimeTokenError extends Enum {
        readonly isNoFunds: boolean;
        readonly isWouldDie: boolean;
        readonly isBelowMinimum: boolean;
        readonly isCannotCreate: boolean;
        readonly isUnknownAsset: boolean;
        readonly isFrozen: boolean;
        readonly isUnsupported: boolean;
        readonly type: 'NoFunds' | 'WouldDie' | 'BelowMinimum' | 'CannotCreate' | 'UnknownAsset' | 'Frozen' | 'Unsupported';
    }
    /** @name SpRuntimeArithmeticError (34) */
    interface SpRuntimeArithmeticError extends Enum {
        readonly isUnderflow: boolean;
        readonly isOverflow: boolean;
        readonly isDivisionByZero: boolean;
        readonly type: 'Underflow' | 'Overflow' | 'DivisionByZero';
    }
    /** @name SpRuntimeTransactionalError (35) */
    interface SpRuntimeTransactionalError extends Enum {
        readonly isLimitReached: boolean;
        readonly isNoLayer: boolean;
        readonly type: 'LimitReached' | 'NoLayer';
    }
    /** @name CumulusPalletParachainSystemEvent (36) */
    interface CumulusPalletParachainSystemEvent extends Enum {
        readonly isValidationFunctionStored: boolean;
        readonly isValidationFunctionApplied: boolean;
        readonly asValidationFunctionApplied: {
            readonly relayChainBlockNum: u32;
        } & Struct;
        readonly isValidationFunctionDiscarded: boolean;
        readonly isUpgradeAuthorized: boolean;
        readonly asUpgradeAuthorized: {
            readonly codeHash: H256;
        } & Struct;
        readonly isDownwardMessagesReceived: boolean;
        readonly asDownwardMessagesReceived: {
            readonly count: u32;
        } & Struct;
        readonly isDownwardMessagesProcessed: boolean;
        readonly asDownwardMessagesProcessed: {
            readonly weightUsed: SpWeightsWeightV2Weight;
            readonly dmqHead: H256;
        } & Struct;
        readonly type: 'ValidationFunctionStored' | 'ValidationFunctionApplied' | 'ValidationFunctionDiscarded' | 'UpgradeAuthorized' | 'DownwardMessagesReceived' | 'DownwardMessagesProcessed';
    }
    /** @name OrmlTokensModuleEvent (37) */
    interface OrmlTokensModuleEvent extends Enum {
        readonly isEndowed: boolean;
        readonly asEndowed: {
            readonly currencyId: u32;
            readonly who: AccountId32;
            readonly amount: u128;
        } & Struct;
        readonly isDustLost: boolean;
        readonly asDustLost: {
            readonly currencyId: u32;
            readonly who: AccountId32;
            readonly amount: u128;
        } & Struct;
        readonly isTransfer: boolean;
        readonly asTransfer: {
            readonly currencyId: u32;
            readonly from: AccountId32;
            readonly to: AccountId32;
            readonly amount: u128;
        } & Struct;
        readonly isReserved: boolean;
        readonly asReserved: {
            readonly currencyId: u32;
            readonly who: AccountId32;
            readonly amount: u128;
        } & Struct;
        readonly isUnreserved: boolean;
        readonly asUnreserved: {
            readonly currencyId: u32;
            readonly who: AccountId32;
            readonly amount: u128;
        } & Struct;
        readonly isReserveRepatriated: boolean;
        readonly asReserveRepatriated: {
            readonly currencyId: u32;
            readonly from: AccountId32;
            readonly to: AccountId32;
            readonly amount: u128;
            readonly status: FrameSupportTokensMiscBalanceStatus;
        } & Struct;
        readonly isBalanceSet: boolean;
        readonly asBalanceSet: {
            readonly currencyId: u32;
            readonly who: AccountId32;
            readonly free: u128;
            readonly reserved: u128;
        } & Struct;
        readonly isTotalIssuanceSet: boolean;
        readonly asTotalIssuanceSet: {
            readonly currencyId: u32;
            readonly amount: u128;
        } & Struct;
        readonly isWithdrawn: boolean;
        readonly asWithdrawn: {
            readonly currencyId: u32;
            readonly who: AccountId32;
            readonly amount: u128;
        } & Struct;
        readonly isSlashed: boolean;
        readonly asSlashed: {
            readonly currencyId: u32;
            readonly who: AccountId32;
            readonly freeAmount: u128;
            readonly reservedAmount: u128;
        } & Struct;
        readonly isDeposited: boolean;
        readonly asDeposited: {
            readonly currencyId: u32;
            readonly who: AccountId32;
            readonly amount: u128;
        } & Struct;
        readonly isLockSet: boolean;
        readonly asLockSet: {
            readonly lockId: U8aFixed;
            readonly currencyId: u32;
            readonly who: AccountId32;
            readonly amount: u128;
        } & Struct;
        readonly isLockRemoved: boolean;
        readonly asLockRemoved: {
            readonly lockId: U8aFixed;
            readonly currencyId: u32;
            readonly who: AccountId32;
        } & Struct;
        readonly isIssued: boolean;
        readonly asIssued: ITuple<[u32, AccountId32, u128]>;
        readonly isMinted: boolean;
        readonly asMinted: ITuple<[u32, AccountId32, u128]>;
        readonly type: 'Endowed' | 'DustLost' | 'Transfer' | 'Reserved' | 'Unreserved' | 'ReserveRepatriated' | 'BalanceSet' | 'TotalIssuanceSet' | 'Withdrawn' | 'Slashed' | 'Deposited' | 'LockSet' | 'LockRemoved' | 'Issued' | 'Minted';
    }
    /** @name FrameSupportTokensMiscBalanceStatus (39) */
    interface FrameSupportTokensMiscBalanceStatus extends Enum {
        readonly isFree: boolean;
        readonly isReserved: boolean;
        readonly type: 'Free' | 'Reserved';
    }
    /** @name PalletTransactionPaymentEvent (41) */
    interface PalletTransactionPaymentEvent extends Enum {
        readonly isTransactionFeePaid: boolean;
        readonly asTransactionFeePaid: {
            readonly who: AccountId32;
            readonly actualFee: u128;
            readonly tip: u128;
        } & Struct;
        readonly type: 'TransactionFeePaid';
    }
    /** @name PalletXykEvent (42) */
    interface PalletXykEvent extends Enum {
        readonly isPoolCreated: boolean;
        readonly asPoolCreated: ITuple<[AccountId32, u32, u128, u32, u128]>;
        readonly isAssetsSwapped: boolean;
        readonly asAssetsSwapped: ITuple<[AccountId32, u32, u128, u32, u128]>;
        readonly isSellAssetFailedDueToSlippage: boolean;
        readonly asSellAssetFailedDueToSlippage: ITuple<[AccountId32, u32, u128, u32, u128, u128]>;
        readonly isBuyAssetFailedDueToSlippage: boolean;
        readonly asBuyAssetFailedDueToSlippage: ITuple<[AccountId32, u32, u128, u32, u128, u128]>;
        readonly isLiquidityMinted: boolean;
        readonly asLiquidityMinted: ITuple<[AccountId32, u32, u128, u32, u128, u32, u128]>;
        readonly isLiquidityBurned: boolean;
        readonly asLiquidityBurned: ITuple<[AccountId32, u32, u128, u32, u128, u32, u128]>;
        readonly isPoolPromotionUpdated: boolean;
        readonly asPoolPromotionUpdated: ITuple<[u32, Option<u8>]>;
        readonly isLiquidityActivated: boolean;
        readonly asLiquidityActivated: ITuple<[AccountId32, u32, u128]>;
        readonly isLiquidityDeactivated: boolean;
        readonly asLiquidityDeactivated: ITuple<[AccountId32, u32, u128]>;
        readonly isRewardsClaimed: boolean;
        readonly asRewardsClaimed: ITuple<[AccountId32, u32, u128]>;
        readonly type: 'PoolCreated' | 'AssetsSwapped' | 'SellAssetFailedDueToSlippage' | 'BuyAssetFailedDueToSlippage' | 'LiquidityMinted' | 'LiquidityBurned' | 'PoolPromotionUpdated' | 'LiquidityActivated' | 'LiquidityDeactivated' | 'RewardsClaimed';
    }
    /** @name PalletTokenTimeoutEvent (44) */
    interface PalletTokenTimeoutEvent extends Enum {
        readonly isTimeoutMetadataUpdated: boolean;
        readonly isTimeoutReleased: boolean;
        readonly asTimeoutReleased: ITuple<[AccountId32, u128]>;
        readonly type: 'TimeoutMetadataUpdated' | 'TimeoutReleased';
    }
    /** @name PalletVestingMangataEvent (45) */
    interface PalletVestingMangataEvent extends Enum {
        readonly isVestingUpdated: boolean;
        readonly asVestingUpdated: ITuple<[AccountId32, u32, u128]>;
        readonly isVestingCompleted: boolean;
        readonly asVestingCompleted: ITuple<[AccountId32, u32]>;
        readonly type: 'VestingUpdated' | 'VestingCompleted';
    }
    /** @name PalletCrowdloanRewardsEvent (46) */
    interface PalletCrowdloanRewardsEvent extends Enum {
        readonly isInitialPaymentMade: boolean;
        readonly asInitialPaymentMade: ITuple<[AccountId32, u128]>;
        readonly isNativeIdentityAssociated: boolean;
        readonly asNativeIdentityAssociated: ITuple<[AccountId32, AccountId32, u128]>;
        readonly isRewardsPaid: boolean;
        readonly asRewardsPaid: ITuple<[AccountId32, u128]>;
        readonly isRewardAddressUpdated: boolean;
        readonly asRewardAddressUpdated: ITuple<[AccountId32, AccountId32]>;
        readonly isInitializedAlreadyInitializedAccount: boolean;
        readonly asInitializedAlreadyInitializedAccount: ITuple<[AccountId32, Option<AccountId32>, u128]>;
        readonly isInitializedAccountWithNotEnoughContribution: boolean;
        readonly asInitializedAccountWithNotEnoughContribution: ITuple<[AccountId32, Option<AccountId32>, u128]>;
        readonly type: 'InitialPaymentMade' | 'NativeIdentityAssociated' | 'RewardsPaid' | 'RewardAddressUpdated' | 'InitializedAlreadyInitializedAccount' | 'InitializedAccountWithNotEnoughContribution';
    }
    /** @name PalletIssuanceEvent (47) */
    interface PalletIssuanceEvent extends Enum {
        readonly isSessionIssuanceIssued: boolean;
        readonly asSessionIssuanceIssued: ITuple<[u32, u128, u128]>;
        readonly isSessionIssuanceRecorded: boolean;
        readonly asSessionIssuanceRecorded: ITuple<[u32, u128, u128]>;
        readonly isIssuanceConfigInitialized: boolean;
        readonly asIssuanceConfigInitialized: PalletIssuanceIssuanceInfo;
        readonly isTgeFinalized: boolean;
        readonly isTgeInstanceFailed: boolean;
        readonly asTgeInstanceFailed: PalletIssuanceTgeInfo;
        readonly isTgeInstanceSucceeded: boolean;
        readonly asTgeInstanceSucceeded: PalletIssuanceTgeInfo;
        readonly type: 'SessionIssuanceIssued' | 'SessionIssuanceRecorded' | 'IssuanceConfigInitialized' | 'TgeFinalized' | 'TgeInstanceFailed' | 'TgeInstanceSucceeded';
    }
    /** @name PalletIssuanceIssuanceInfo (48) */
    interface PalletIssuanceIssuanceInfo extends Struct {
        readonly cap: u128;
        readonly issuanceAtInit: u128;
        readonly linearIssuanceBlocks: u32;
        readonly liquidityMiningSplit: Perbill;
        readonly stakingSplit: Perbill;
        readonly totalCrowdloanAllocation: u128;
    }
    /** @name PalletIssuanceTgeInfo (50) */
    interface PalletIssuanceTgeInfo extends Struct {
        readonly who: AccountId32;
        readonly amount: u128;
    }
    /** @name ParachainStakingEvent (51) */
    interface ParachainStakingEvent extends Enum {
        readonly isNewRound: boolean;
        readonly asNewRound: ITuple<[u32, u32, u32, u128]>;
        readonly isJoinedCollatorCandidates: boolean;
        readonly asJoinedCollatorCandidates: ITuple<[AccountId32, u128, u128]>;
        readonly isCollatorChosen: boolean;
        readonly asCollatorChosen: ITuple<[u32, AccountId32, u128]>;
        readonly isCandidateBondMoreRequested: boolean;
        readonly asCandidateBondMoreRequested: ITuple<[AccountId32, u128, u32]>;
        readonly isCandidateBondLessRequested: boolean;
        readonly asCandidateBondLessRequested: ITuple<[AccountId32, u128, u32]>;
        readonly isCandidateBondedMore: boolean;
        readonly asCandidateBondedMore: ITuple<[AccountId32, u128, u128]>;
        readonly isCandidateBondedLess: boolean;
        readonly asCandidateBondedLess: ITuple<[AccountId32, u128, u128]>;
        readonly isCandidateWentOffline: boolean;
        readonly asCandidateWentOffline: ITuple<[u32, AccountId32]>;
        readonly isCandidateBackOnline: boolean;
        readonly asCandidateBackOnline: ITuple<[u32, AccountId32]>;
        readonly isCandidateScheduledExit: boolean;
        readonly asCandidateScheduledExit: ITuple<[u32, AccountId32, u32]>;
        readonly isCancelledCandidateExit: boolean;
        readonly asCancelledCandidateExit: AccountId32;
        readonly isCancelledCandidateBondChange: boolean;
        readonly asCancelledCandidateBondChange: ITuple<[AccountId32, ParachainStakingCandidateBondRequest]>;
        readonly isCandidateLeft: boolean;
        readonly asCandidateLeft: ITuple<[AccountId32, u128, u128]>;
        readonly isDelegationIncreaseScheduled: boolean;
        readonly asDelegationIncreaseScheduled: ITuple<[AccountId32, AccountId32, u128, u32]>;
        readonly isDelegationDecreaseScheduled: boolean;
        readonly asDelegationDecreaseScheduled: ITuple<[AccountId32, AccountId32, u128, u32]>;
        readonly isDelegationIncreased: boolean;
        readonly asDelegationIncreased: ITuple<[AccountId32, AccountId32, u128, bool]>;
        readonly isDelegationDecreased: boolean;
        readonly asDelegationDecreased: ITuple<[AccountId32, AccountId32, u128, bool]>;
        readonly isDelegatorExitScheduled: boolean;
        readonly asDelegatorExitScheduled: ITuple<[u32, AccountId32, u32]>;
        readonly isDelegationRevocationScheduled: boolean;
        readonly asDelegationRevocationScheduled: ITuple<[u32, AccountId32, AccountId32, u32]>;
        readonly isDelegatorLeft: boolean;
        readonly asDelegatorLeft: ITuple<[AccountId32, u128]>;
        readonly isDelegationRevoked: boolean;
        readonly asDelegationRevoked: ITuple<[AccountId32, AccountId32, u128]>;
        readonly isDelegatorExitCancelled: boolean;
        readonly asDelegatorExitCancelled: AccountId32;
        readonly isCancelledDelegationRequest: boolean;
        readonly asCancelledDelegationRequest: ITuple<[AccountId32, ParachainStakingDelegationRequest]>;
        readonly isDelegation: boolean;
        readonly asDelegation: ITuple<[AccountId32, u128, AccountId32, ParachainStakingDelegatorAdded]>;
        readonly isDelegatorLeftCandidate: boolean;
        readonly asDelegatorLeftCandidate: ITuple<[AccountId32, AccountId32, u128, u128]>;
        readonly isDelegatorDueReward: boolean;
        readonly asDelegatorDueReward: ITuple<[AccountId32, AccountId32, u128]>;
        readonly isRewarded: boolean;
        readonly asRewarded: ITuple<[AccountId32, u128]>;
        readonly isStakeExpectationsSet: boolean;
        readonly asStakeExpectationsSet: ITuple<[u128, u128, u128]>;
        readonly isTotalSelectedSet: boolean;
        readonly asTotalSelectedSet: ITuple<[u32, u32]>;
        readonly isCollatorCommissionSet: boolean;
        readonly asCollatorCommissionSet: ITuple<[Perbill, Perbill]>;
        readonly type: 'NewRound' | 'JoinedCollatorCandidates' | 'CollatorChosen' | 'CandidateBondMoreRequested' | 'CandidateBondLessRequested' | 'CandidateBondedMore' | 'CandidateBondedLess' | 'CandidateWentOffline' | 'CandidateBackOnline' | 'CandidateScheduledExit' | 'CancelledCandidateExit' | 'CancelledCandidateBondChange' | 'CandidateLeft' | 'DelegationIncreaseScheduled' | 'DelegationDecreaseScheduled' | 'DelegationIncreased' | 'DelegationDecreased' | 'DelegatorExitScheduled' | 'DelegationRevocationScheduled' | 'DelegatorLeft' | 'DelegationRevoked' | 'DelegatorExitCancelled' | 'CancelledDelegationRequest' | 'Delegation' | 'DelegatorLeftCandidate' | 'DelegatorDueReward' | 'Rewarded' | 'StakeExpectationsSet' | 'TotalSelectedSet' | 'CollatorCommissionSet';
    }
    /** @name ParachainStakingCandidateBondRequest (52) */
    interface ParachainStakingCandidateBondRequest extends Struct {
        readonly amount: u128;
        readonly change: ParachainStakingCandidateBondChange;
        readonly whenExecutable: u32;
    }
    /** @name ParachainStakingCandidateBondChange (53) */
    interface ParachainStakingCandidateBondChange extends Enum {
        readonly isIncrease: boolean;
        readonly isDecrease: boolean;
        readonly type: 'Increase' | 'Decrease';
    }
    /** @name ParachainStakingDelegationRequest (54) */
    interface ParachainStakingDelegationRequest extends Struct {
        readonly collator: AccountId32;
        readonly amount: u128;
        readonly whenExecutable: u32;
        readonly action: ParachainStakingDelegationChange;
    }
    /** @name ParachainStakingDelegationChange (55) */
    interface ParachainStakingDelegationChange extends Enum {
        readonly isRevoke: boolean;
        readonly isIncrease: boolean;
        readonly isDecrease: boolean;
        readonly type: 'Revoke' | 'Increase' | 'Decrease';
    }
    /** @name ParachainStakingDelegatorAdded (56) */
    interface ParachainStakingDelegatorAdded extends Enum {
        readonly isAddedToTop: boolean;
        readonly asAddedToTop: {
            readonly newTotal: u128;
        } & Struct;
        readonly isAddedToBottom: boolean;
        readonly type: 'AddedToTop' | 'AddedToBottom';
    }
    /** @name PalletSessionEvent (57) */
    interface PalletSessionEvent extends Enum {
        readonly isNewSession: boolean;
        readonly asNewSession: {
            readonly sessionIndex: u32;
        } & Struct;
        readonly type: 'NewSession';
    }
    /** @name PalletMultipurposeLiquidityEvent (58) */
    interface PalletMultipurposeLiquidityEvent extends Enum {
        readonly isVestingTokensReserved: boolean;
        readonly asVestingTokensReserved: ITuple<[AccountId32, u32, u128]>;
        readonly isTokensRelockedFromReserve: boolean;
        readonly asTokensRelockedFromReserve: ITuple<[AccountId32, u32, u128, u128]>;
        readonly type: 'VestingTokensReserved' | 'TokensRelockedFromReserve';
    }
    /** @name CumulusPalletXcmpQueueEvent (59) */
    interface CumulusPalletXcmpQueueEvent extends Enum {
        readonly isSuccess: boolean;
        readonly asSuccess: {
            readonly messageHash: Option<H256>;
            readonly weight: SpWeightsWeightV2Weight;
        } & Struct;
        readonly isFail: boolean;
        readonly asFail: {
            readonly messageHash: Option<H256>;
            readonly error: XcmV2TraitsError;
            readonly weight: SpWeightsWeightV2Weight;
        } & Struct;
        readonly isBadVersion: boolean;
        readonly asBadVersion: {
            readonly messageHash: Option<H256>;
        } & Struct;
        readonly isBadFormat: boolean;
        readonly asBadFormat: {
            readonly messageHash: Option<H256>;
        } & Struct;
        readonly isUpwardMessageSent: boolean;
        readonly asUpwardMessageSent: {
            readonly messageHash: Option<H256>;
        } & Struct;
        readonly isXcmpMessageSent: boolean;
        readonly asXcmpMessageSent: {
            readonly messageHash: Option<H256>;
        } & Struct;
        readonly isOverweightEnqueued: boolean;
        readonly asOverweightEnqueued: {
            readonly sender: u32;
            readonly sentAt: u32;
            readonly index: u64;
            readonly required: SpWeightsWeightV2Weight;
        } & Struct;
        readonly isOverweightServiced: boolean;
        readonly asOverweightServiced: {
            readonly index: u64;
            readonly used: SpWeightsWeightV2Weight;
        } & Struct;
        readonly type: 'Success' | 'Fail' | 'BadVersion' | 'BadFormat' | 'UpwardMessageSent' | 'XcmpMessageSent' | 'OverweightEnqueued' | 'OverweightServiced';
    }
    /** @name XcmV2TraitsError (61) */
    interface XcmV2TraitsError extends Enum {
        readonly isOverflow: boolean;
        readonly isUnimplemented: boolean;
        readonly isUntrustedReserveLocation: boolean;
        readonly isUntrustedTeleportLocation: boolean;
        readonly isMultiLocationFull: boolean;
        readonly isMultiLocationNotInvertible: boolean;
        readonly isBadOrigin: boolean;
        readonly isInvalidLocation: boolean;
        readonly isAssetNotFound: boolean;
        readonly isFailedToTransactAsset: boolean;
        readonly isNotWithdrawable: boolean;
        readonly isLocationCannotHold: boolean;
        readonly isExceedsMaxMessageSize: boolean;
        readonly isDestinationUnsupported: boolean;
        readonly isTransport: boolean;
        readonly isUnroutable: boolean;
        readonly isUnknownClaim: boolean;
        readonly isFailedToDecode: boolean;
        readonly isMaxWeightInvalid: boolean;
        readonly isNotHoldingFees: boolean;
        readonly isTooExpensive: boolean;
        readonly isTrap: boolean;
        readonly asTrap: u64;
        readonly isUnhandledXcmVersion: boolean;
        readonly isWeightLimitReached: boolean;
        readonly asWeightLimitReached: u64;
        readonly isBarrier: boolean;
        readonly isWeightNotComputable: boolean;
        readonly type: 'Overflow' | 'Unimplemented' | 'UntrustedReserveLocation' | 'UntrustedTeleportLocation' | 'MultiLocationFull' | 'MultiLocationNotInvertible' | 'BadOrigin' | 'InvalidLocation' | 'AssetNotFound' | 'FailedToTransactAsset' | 'NotWithdrawable' | 'LocationCannotHold' | 'ExceedsMaxMessageSize' | 'DestinationUnsupported' | 'Transport' | 'Unroutable' | 'UnknownClaim' | 'FailedToDecode' | 'MaxWeightInvalid' | 'NotHoldingFees' | 'TooExpensive' | 'Trap' | 'UnhandledXcmVersion' | 'WeightLimitReached' | 'Barrier' | 'WeightNotComputable';
    }
    /** @name PalletXcmEvent (63) */
    interface PalletXcmEvent extends Enum {
        readonly isAttempted: boolean;
        readonly asAttempted: XcmV2TraitsOutcome;
        readonly isSent: boolean;
        readonly asSent: ITuple<[XcmV1MultiLocation, XcmV1MultiLocation, XcmV2Xcm]>;
        readonly isUnexpectedResponse: boolean;
        readonly asUnexpectedResponse: ITuple<[XcmV1MultiLocation, u64]>;
        readonly isResponseReady: boolean;
        readonly asResponseReady: ITuple<[u64, XcmV2Response]>;
        readonly isNotified: boolean;
        readonly asNotified: ITuple<[u64, u8, u8]>;
        readonly isNotifyOverweight: boolean;
        readonly asNotifyOverweight: ITuple<[u64, u8, u8, SpWeightsWeightV2Weight, SpWeightsWeightV2Weight]>;
        readonly isNotifyDispatchError: boolean;
        readonly asNotifyDispatchError: ITuple<[u64, u8, u8]>;
        readonly isNotifyDecodeFailed: boolean;
        readonly asNotifyDecodeFailed: ITuple<[u64, u8, u8]>;
        readonly isInvalidResponder: boolean;
        readonly asInvalidResponder: ITuple<[XcmV1MultiLocation, u64, Option<XcmV1MultiLocation>]>;
        readonly isInvalidResponderVersion: boolean;
        readonly asInvalidResponderVersion: ITuple<[XcmV1MultiLocation, u64]>;
        readonly isResponseTaken: boolean;
        readonly asResponseTaken: u64;
        readonly isAssetsTrapped: boolean;
        readonly asAssetsTrapped: ITuple<[H256, XcmV1MultiLocation, XcmVersionedMultiAssets]>;
        readonly isVersionChangeNotified: boolean;
        readonly asVersionChangeNotified: ITuple<[XcmV1MultiLocation, u32]>;
        readonly isSupportedVersionChanged: boolean;
        readonly asSupportedVersionChanged: ITuple<[XcmV1MultiLocation, u32]>;
        readonly isNotifyTargetSendFail: boolean;
        readonly asNotifyTargetSendFail: ITuple<[XcmV1MultiLocation, u64, XcmV2TraitsError]>;
        readonly isNotifyTargetMigrationFail: boolean;
        readonly asNotifyTargetMigrationFail: ITuple<[XcmVersionedMultiLocation, u64]>;
        readonly isAssetsClaimed: boolean;
        readonly asAssetsClaimed: ITuple<[H256, XcmV1MultiLocation, XcmVersionedMultiAssets]>;
        readonly type: 'Attempted' | 'Sent' | 'UnexpectedResponse' | 'ResponseReady' | 'Notified' | 'NotifyOverweight' | 'NotifyDispatchError' | 'NotifyDecodeFailed' | 'InvalidResponder' | 'InvalidResponderVersion' | 'ResponseTaken' | 'AssetsTrapped' | 'VersionChangeNotified' | 'SupportedVersionChanged' | 'NotifyTargetSendFail' | 'NotifyTargetMigrationFail' | 'AssetsClaimed';
    }
    /** @name XcmV2TraitsOutcome (64) */
    interface XcmV2TraitsOutcome extends Enum {
        readonly isComplete: boolean;
        readonly asComplete: u64;
        readonly isIncomplete: boolean;
        readonly asIncomplete: ITuple<[u64, XcmV2TraitsError]>;
        readonly isError: boolean;
        readonly asError: XcmV2TraitsError;
        readonly type: 'Complete' | 'Incomplete' | 'Error';
    }
    /** @name XcmV1MultiLocation (65) */
    interface XcmV1MultiLocation extends Struct {
        readonly parents: u8;
        readonly interior: XcmV1MultilocationJunctions;
    }
    /** @name XcmV1MultilocationJunctions (66) */
    interface XcmV1MultilocationJunctions extends Enum {
        readonly isHere: boolean;
        readonly isX1: boolean;
        readonly asX1: XcmV1Junction;
        readonly isX2: boolean;
        readonly asX2: ITuple<[XcmV1Junction, XcmV1Junction]>;
        readonly isX3: boolean;
        readonly asX3: ITuple<[XcmV1Junction, XcmV1Junction, XcmV1Junction]>;
        readonly isX4: boolean;
        readonly asX4: ITuple<[XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction]>;
        readonly isX5: boolean;
        readonly asX5: ITuple<[XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction]>;
        readonly isX6: boolean;
        readonly asX6: ITuple<[XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction]>;
        readonly isX7: boolean;
        readonly asX7: ITuple<[XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction]>;
        readonly isX8: boolean;
        readonly asX8: ITuple<[XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction, XcmV1Junction]>;
        readonly type: 'Here' | 'X1' | 'X2' | 'X3' | 'X4' | 'X5' | 'X6' | 'X7' | 'X8';
    }
    /** @name XcmV1Junction (67) */
    interface XcmV1Junction extends Enum {
        readonly isParachain: boolean;
        readonly asParachain: Compact<u32>;
        readonly isAccountId32: boolean;
        readonly asAccountId32: {
            readonly network: XcmV0JunctionNetworkId;
            readonly id: U8aFixed;
        } & Struct;
        readonly isAccountIndex64: boolean;
        readonly asAccountIndex64: {
            readonly network: XcmV0JunctionNetworkId;
            readonly index: Compact<u64>;
        } & Struct;
        readonly isAccountKey20: boolean;
        readonly asAccountKey20: {
            readonly network: XcmV0JunctionNetworkId;
            readonly key: U8aFixed;
        } & Struct;
        readonly isPalletInstance: boolean;
        readonly asPalletInstance: u8;
        readonly isGeneralIndex: boolean;
        readonly asGeneralIndex: Compact<u128>;
        readonly isGeneralKey: boolean;
        readonly asGeneralKey: Bytes;
        readonly isOnlyChild: boolean;
        readonly isPlurality: boolean;
        readonly asPlurality: {
            readonly id: XcmV0JunctionBodyId;
            readonly part: XcmV0JunctionBodyPart;
        } & Struct;
        readonly type: 'Parachain' | 'AccountId32' | 'AccountIndex64' | 'AccountKey20' | 'PalletInstance' | 'GeneralIndex' | 'GeneralKey' | 'OnlyChild' | 'Plurality';
    }
    /** @name XcmV0JunctionNetworkId (69) */
    interface XcmV0JunctionNetworkId extends Enum {
        readonly isAny: boolean;
        readonly isNamed: boolean;
        readonly asNamed: Bytes;
        readonly isPolkadot: boolean;
        readonly isKusama: boolean;
        readonly type: 'Any' | 'Named' | 'Polkadot' | 'Kusama';
    }
    /** @name XcmV0JunctionBodyId (73) */
    interface XcmV0JunctionBodyId extends Enum {
        readonly isUnit: boolean;
        readonly isNamed: boolean;
        readonly asNamed: Bytes;
        readonly isIndex: boolean;
        readonly asIndex: Compact<u32>;
        readonly isExecutive: boolean;
        readonly isTechnical: boolean;
        readonly isLegislative: boolean;
        readonly isJudicial: boolean;
        readonly type: 'Unit' | 'Named' | 'Index' | 'Executive' | 'Technical' | 'Legislative' | 'Judicial';
    }
    /** @name XcmV0JunctionBodyPart (74) */
    interface XcmV0JunctionBodyPart extends Enum {
        readonly isVoice: boolean;
        readonly isMembers: boolean;
        readonly asMembers: {
            readonly count: Compact<u32>;
        } & Struct;
        readonly isFraction: boolean;
        readonly asFraction: {
            readonly nom: Compact<u32>;
            readonly denom: Compact<u32>;
        } & Struct;
        readonly isAtLeastProportion: boolean;
        readonly asAtLeastProportion: {
            readonly nom: Compact<u32>;
            readonly denom: Compact<u32>;
        } & Struct;
        readonly isMoreThanProportion: boolean;
        readonly asMoreThanProportion: {
            readonly nom: Compact<u32>;
            readonly denom: Compact<u32>;
        } & Struct;
        readonly type: 'Voice' | 'Members' | 'Fraction' | 'AtLeastProportion' | 'MoreThanProportion';
    }
    /** @name XcmV2Xcm (75) */
    interface XcmV2Xcm extends Vec<XcmV2Instruction> {
    }
    /** @name XcmV2Instruction (77) */
    interface XcmV2Instruction extends Enum {
        readonly isWithdrawAsset: boolean;
        readonly asWithdrawAsset: XcmV1MultiassetMultiAssets;
        readonly isReserveAssetDeposited: boolean;
        readonly asReserveAssetDeposited: XcmV1MultiassetMultiAssets;
        readonly isReceiveTeleportedAsset: boolean;
        readonly asReceiveTeleportedAsset: XcmV1MultiassetMultiAssets;
        readonly isQueryResponse: boolean;
        readonly asQueryResponse: {
            readonly queryId: Compact<u64>;
            readonly response: XcmV2Response;
            readonly maxWeight: Compact<u64>;
        } & Struct;
        readonly isTransferAsset: boolean;
        readonly asTransferAsset: {
            readonly assets: XcmV1MultiassetMultiAssets;
            readonly beneficiary: XcmV1MultiLocation;
        } & Struct;
        readonly isTransferReserveAsset: boolean;
        readonly asTransferReserveAsset: {
            readonly assets: XcmV1MultiassetMultiAssets;
            readonly dest: XcmV1MultiLocation;
            readonly xcm: XcmV2Xcm;
        } & Struct;
        readonly isTransact: boolean;
        readonly asTransact: {
            readonly originType: XcmV0OriginKind;
            readonly requireWeightAtMost: Compact<u64>;
            readonly call: XcmDoubleEncoded;
        } & Struct;
        readonly isHrmpNewChannelOpenRequest: boolean;
        readonly asHrmpNewChannelOpenRequest: {
            readonly sender: Compact<u32>;
            readonly maxMessageSize: Compact<u32>;
            readonly maxCapacity: Compact<u32>;
        } & Struct;
        readonly isHrmpChannelAccepted: boolean;
        readonly asHrmpChannelAccepted: {
            readonly recipient: Compact<u32>;
        } & Struct;
        readonly isHrmpChannelClosing: boolean;
        readonly asHrmpChannelClosing: {
            readonly initiator: Compact<u32>;
            readonly sender: Compact<u32>;
            readonly recipient: Compact<u32>;
        } & Struct;
        readonly isClearOrigin: boolean;
        readonly isDescendOrigin: boolean;
        readonly asDescendOrigin: XcmV1MultilocationJunctions;
        readonly isReportError: boolean;
        readonly asReportError: {
            readonly queryId: Compact<u64>;
            readonly dest: XcmV1MultiLocation;
            readonly maxResponseWeight: Compact<u64>;
        } & Struct;
        readonly isDepositAsset: boolean;
        readonly asDepositAsset: {
            readonly assets: XcmV1MultiassetMultiAssetFilter;
            readonly maxAssets: Compact<u32>;
            readonly beneficiary: XcmV1MultiLocation;
        } & Struct;
        readonly isDepositReserveAsset: boolean;
        readonly asDepositReserveAsset: {
            readonly assets: XcmV1MultiassetMultiAssetFilter;
            readonly maxAssets: Compact<u32>;
            readonly dest: XcmV1MultiLocation;
            readonly xcm: XcmV2Xcm;
        } & Struct;
        readonly isExchangeAsset: boolean;
        readonly asExchangeAsset: {
            readonly give: XcmV1MultiassetMultiAssetFilter;
            readonly receive: XcmV1MultiassetMultiAssets;
        } & Struct;
        readonly isInitiateReserveWithdraw: boolean;
        readonly asInitiateReserveWithdraw: {
            readonly assets: XcmV1MultiassetMultiAssetFilter;
            readonly reserve: XcmV1MultiLocation;
            readonly xcm: XcmV2Xcm;
        } & Struct;
        readonly isInitiateTeleport: boolean;
        readonly asInitiateTeleport: {
            readonly assets: XcmV1MultiassetMultiAssetFilter;
            readonly dest: XcmV1MultiLocation;
            readonly xcm: XcmV2Xcm;
        } & Struct;
        readonly isQueryHolding: boolean;
        readonly asQueryHolding: {
            readonly queryId: Compact<u64>;
            readonly dest: XcmV1MultiLocation;
            readonly assets: XcmV1MultiassetMultiAssetFilter;
            readonly maxResponseWeight: Compact<u64>;
        } & Struct;
        readonly isBuyExecution: boolean;
        readonly asBuyExecution: {
            readonly fees: XcmV1MultiAsset;
            readonly weightLimit: XcmV2WeightLimit;
        } & Struct;
        readonly isRefundSurplus: boolean;
        readonly isSetErrorHandler: boolean;
        readonly asSetErrorHandler: XcmV2Xcm;
        readonly isSetAppendix: boolean;
        readonly asSetAppendix: XcmV2Xcm;
        readonly isClearError: boolean;
        readonly isClaimAsset: boolean;
        readonly asClaimAsset: {
            readonly assets: XcmV1MultiassetMultiAssets;
            readonly ticket: XcmV1MultiLocation;
        } & Struct;
        readonly isTrap: boolean;
        readonly asTrap: Compact<u64>;
        readonly isSubscribeVersion: boolean;
        readonly asSubscribeVersion: {
            readonly queryId: Compact<u64>;
            readonly maxResponseWeight: Compact<u64>;
        } & Struct;
        readonly isUnsubscribeVersion: boolean;
        readonly type: 'WithdrawAsset' | 'ReserveAssetDeposited' | 'ReceiveTeleportedAsset' | 'QueryResponse' | 'TransferAsset' | 'TransferReserveAsset' | 'Transact' | 'HrmpNewChannelOpenRequest' | 'HrmpChannelAccepted' | 'HrmpChannelClosing' | 'ClearOrigin' | 'DescendOrigin' | 'ReportError' | 'DepositAsset' | 'DepositReserveAsset' | 'ExchangeAsset' | 'InitiateReserveWithdraw' | 'InitiateTeleport' | 'QueryHolding' | 'BuyExecution' | 'RefundSurplus' | 'SetErrorHandler' | 'SetAppendix' | 'ClearError' | 'ClaimAsset' | 'Trap' | 'SubscribeVersion' | 'UnsubscribeVersion';
    }
    /** @name XcmV1MultiassetMultiAssets (78) */
    interface XcmV1MultiassetMultiAssets extends Vec<XcmV1MultiAsset> {
    }
    /** @name XcmV1MultiAsset (80) */
    interface XcmV1MultiAsset extends Struct {
        readonly id: XcmV1MultiassetAssetId;
        readonly fun: XcmV1MultiassetFungibility;
    }
    /** @name XcmV1MultiassetAssetId (81) */
    interface XcmV1MultiassetAssetId extends Enum {
        readonly isConcrete: boolean;
        readonly asConcrete: XcmV1MultiLocation;
        readonly isAbstract: boolean;
        readonly asAbstract: Bytes;
        readonly type: 'Concrete' | 'Abstract';
    }
    /** @name XcmV1MultiassetFungibility (82) */
    interface XcmV1MultiassetFungibility extends Enum {
        readonly isFungible: boolean;
        readonly asFungible: Compact<u128>;
        readonly isNonFungible: boolean;
        readonly asNonFungible: XcmV1MultiassetAssetInstance;
        readonly type: 'Fungible' | 'NonFungible';
    }
    /** @name XcmV1MultiassetAssetInstance (83) */
    interface XcmV1MultiassetAssetInstance extends Enum {
        readonly isUndefined: boolean;
        readonly isIndex: boolean;
        readonly asIndex: Compact<u128>;
        readonly isArray4: boolean;
        readonly asArray4: U8aFixed;
        readonly isArray8: boolean;
        readonly asArray8: U8aFixed;
        readonly isArray16: boolean;
        readonly asArray16: U8aFixed;
        readonly isArray32: boolean;
        readonly asArray32: U8aFixed;
        readonly isBlob: boolean;
        readonly asBlob: Bytes;
        readonly type: 'Undefined' | 'Index' | 'Array4' | 'Array8' | 'Array16' | 'Array32' | 'Blob';
    }
    /** @name XcmV2Response (85) */
    interface XcmV2Response extends Enum {
        readonly isNull: boolean;
        readonly isAssets: boolean;
        readonly asAssets: XcmV1MultiassetMultiAssets;
        readonly isExecutionResult: boolean;
        readonly asExecutionResult: Option<ITuple<[u32, XcmV2TraitsError]>>;
        readonly isVersion: boolean;
        readonly asVersion: u32;
        readonly type: 'Null' | 'Assets' | 'ExecutionResult' | 'Version';
    }
    /** @name XcmV0OriginKind (88) */
    interface XcmV0OriginKind extends Enum {
        readonly isNative: boolean;
        readonly isSovereignAccount: boolean;
        readonly isSuperuser: boolean;
        readonly isXcm: boolean;
        readonly type: 'Native' | 'SovereignAccount' | 'Superuser' | 'Xcm';
    }
    /** @name XcmDoubleEncoded (89) */
    interface XcmDoubleEncoded extends Struct {
        readonly encoded: Bytes;
    }
    /** @name XcmV1MultiassetMultiAssetFilter (90) */
    interface XcmV1MultiassetMultiAssetFilter extends Enum {
        readonly isDefinite: boolean;
        readonly asDefinite: XcmV1MultiassetMultiAssets;
        readonly isWild: boolean;
        readonly asWild: XcmV1MultiassetWildMultiAsset;
        readonly type: 'Definite' | 'Wild';
    }
    /** @name XcmV1MultiassetWildMultiAsset (91) */
    interface XcmV1MultiassetWildMultiAsset extends Enum {
        readonly isAll: boolean;
        readonly isAllOf: boolean;
        readonly asAllOf: {
            readonly id: XcmV1MultiassetAssetId;
            readonly fun: XcmV1MultiassetWildFungibility;
        } & Struct;
        readonly type: 'All' | 'AllOf';
    }
    /** @name XcmV1MultiassetWildFungibility (92) */
    interface XcmV1MultiassetWildFungibility extends Enum {
        readonly isFungible: boolean;
        readonly isNonFungible: boolean;
        readonly type: 'Fungible' | 'NonFungible';
    }
    /** @name XcmV2WeightLimit (93) */
    interface XcmV2WeightLimit extends Enum {
        readonly isUnlimited: boolean;
        readonly isLimited: boolean;
        readonly asLimited: Compact<u64>;
        readonly type: 'Unlimited' | 'Limited';
    }
    /** @name XcmVersionedMultiAssets (95) */
    interface XcmVersionedMultiAssets extends Enum {
        readonly isV0: boolean;
        readonly asV0: Vec<XcmV0MultiAsset>;
        readonly isV1: boolean;
        readonly asV1: XcmV1MultiassetMultiAssets;
        readonly type: 'V0' | 'V1';
    }
    /** @name XcmV0MultiAsset (97) */
    interface XcmV0MultiAsset extends Enum {
        readonly isNone: boolean;
        readonly isAll: boolean;
        readonly isAllFungible: boolean;
        readonly isAllNonFungible: boolean;
        readonly isAllAbstractFungible: boolean;
        readonly asAllAbstractFungible: {
            readonly id: Bytes;
        } & Struct;
        readonly isAllAbstractNonFungible: boolean;
        readonly asAllAbstractNonFungible: {
            readonly class: Bytes;
        } & Struct;
        readonly isAllConcreteFungible: boolean;
        readonly asAllConcreteFungible: {
            readonly id: XcmV0MultiLocation;
        } & Struct;
        readonly isAllConcreteNonFungible: boolean;
        readonly asAllConcreteNonFungible: {
            readonly class: XcmV0MultiLocation;
        } & Struct;
        readonly isAbstractFungible: boolean;
        readonly asAbstractFungible: {
            readonly id: Bytes;
            readonly amount: Compact<u128>;
        } & Struct;
        readonly isAbstractNonFungible: boolean;
        readonly asAbstractNonFungible: {
            readonly class: Bytes;
            readonly instance: XcmV1MultiassetAssetInstance;
        } & Struct;
        readonly isConcreteFungible: boolean;
        readonly asConcreteFungible: {
            readonly id: XcmV0MultiLocation;
            readonly amount: Compact<u128>;
        } & Struct;
        readonly isConcreteNonFungible: boolean;
        readonly asConcreteNonFungible: {
            readonly class: XcmV0MultiLocation;
            readonly instance: XcmV1MultiassetAssetInstance;
        } & Struct;
        readonly type: 'None' | 'All' | 'AllFungible' | 'AllNonFungible' | 'AllAbstractFungible' | 'AllAbstractNonFungible' | 'AllConcreteFungible' | 'AllConcreteNonFungible' | 'AbstractFungible' | 'AbstractNonFungible' | 'ConcreteFungible' | 'ConcreteNonFungible';
    }
    /** @name XcmV0MultiLocation (98) */
    interface XcmV0MultiLocation extends Enum {
        readonly isNull: boolean;
        readonly isX1: boolean;
        readonly asX1: XcmV0Junction;
        readonly isX2: boolean;
        readonly asX2: ITuple<[XcmV0Junction, XcmV0Junction]>;
        readonly isX3: boolean;
        readonly asX3: ITuple<[XcmV0Junction, XcmV0Junction, XcmV0Junction]>;
        readonly isX4: boolean;
        readonly asX4: ITuple<[XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction]>;
        readonly isX5: boolean;
        readonly asX5: ITuple<[XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction]>;
        readonly isX6: boolean;
        readonly asX6: ITuple<[XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction]>;
        readonly isX7: boolean;
        readonly asX7: ITuple<[XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction]>;
        readonly isX8: boolean;
        readonly asX8: ITuple<[XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction, XcmV0Junction]>;
        readonly type: 'Null' | 'X1' | 'X2' | 'X3' | 'X4' | 'X5' | 'X6' | 'X7' | 'X8';
    }
    /** @name XcmV0Junction (99) */
    interface XcmV0Junction extends Enum {
        readonly isParent: boolean;
        readonly isParachain: boolean;
        readonly asParachain: Compact<u32>;
        readonly isAccountId32: boolean;
        readonly asAccountId32: {
            readonly network: XcmV0JunctionNetworkId;
            readonly id: U8aFixed;
        } & Struct;
        readonly isAccountIndex64: boolean;
        readonly asAccountIndex64: {
            readonly network: XcmV0JunctionNetworkId;
            readonly index: Compact<u64>;
        } & Struct;
        readonly isAccountKey20: boolean;
        readonly asAccountKey20: {
            readonly network: XcmV0JunctionNetworkId;
            readonly key: U8aFixed;
        } & Struct;
        readonly isPalletInstance: boolean;
        readonly asPalletInstance: u8;
        readonly isGeneralIndex: boolean;
        readonly asGeneralIndex: Compact<u128>;
        readonly isGeneralKey: boolean;
        readonly asGeneralKey: Bytes;
        readonly isOnlyChild: boolean;
        readonly isPlurality: boolean;
        readonly asPlurality: {
            readonly id: XcmV0JunctionBodyId;
            readonly part: XcmV0JunctionBodyPart;
        } & Struct;
        readonly type: 'Parent' | 'Parachain' | 'AccountId32' | 'AccountIndex64' | 'AccountKey20' | 'PalletInstance' | 'GeneralIndex' | 'GeneralKey' | 'OnlyChild' | 'Plurality';
    }
    /** @name XcmVersionedMultiLocation (100) */
    interface XcmVersionedMultiLocation extends Enum {
        readonly isV0: boolean;
        readonly asV0: XcmV0MultiLocation;
        readonly isV1: boolean;
        readonly asV1: XcmV1MultiLocation;
        readonly type: 'V0' | 'V1';
    }
    /** @name CumulusPalletXcmEvent (101) */
    interface CumulusPalletXcmEvent extends Enum {
        readonly isInvalidFormat: boolean;
        readonly asInvalidFormat: U8aFixed;
        readonly isUnsupportedVersion: boolean;
        readonly asUnsupportedVersion: U8aFixed;
        readonly isExecutedDownward: boolean;
        readonly asExecutedDownward: ITuple<[U8aFixed, XcmV2TraitsOutcome]>;
        readonly type: 'InvalidFormat' | 'UnsupportedVersion' | 'ExecutedDownward';
    }
    /** @name CumulusPalletDmpQueueEvent (102) */
    interface CumulusPalletDmpQueueEvent extends Enum {
        readonly isInvalidFormat: boolean;
        readonly asInvalidFormat: {
            readonly messageId: U8aFixed;
        } & Struct;
        readonly isUnsupportedVersion: boolean;
        readonly asUnsupportedVersion: {
            readonly messageId: U8aFixed;
        } & Struct;
        readonly isExecutedDownward: boolean;
        readonly asExecutedDownward: {
            readonly messageId: U8aFixed;
            readonly outcome: XcmV2TraitsOutcome;
        } & Struct;
        readonly isWeightExhausted: boolean;
        readonly asWeightExhausted: {
            readonly messageId: U8aFixed;
            readonly remainingWeight: SpWeightsWeightV2Weight;
            readonly requiredWeight: SpWeightsWeightV2Weight;
        } & Struct;
        readonly isOverweightEnqueued: boolean;
        readonly asOverweightEnqueued: {
            readonly messageId: U8aFixed;
            readonly overweightIndex: u64;
            readonly requiredWeight: SpWeightsWeightV2Weight;
        } & Struct;
        readonly isOverweightServiced: boolean;
        readonly asOverweightServiced: {
            readonly overweightIndex: u64;
            readonly weightUsed: SpWeightsWeightV2Weight;
        } & Struct;
        readonly type: 'InvalidFormat' | 'UnsupportedVersion' | 'ExecutedDownward' | 'WeightExhausted' | 'OverweightEnqueued' | 'OverweightServiced';
    }
    /** @name OrmlXtokensModuleEvent (103) */
    interface OrmlXtokensModuleEvent extends Enum {
        readonly isTransferredMultiAssets: boolean;
        readonly asTransferredMultiAssets: {
            readonly sender: AccountId32;
            readonly assets: XcmV1MultiassetMultiAssets;
            readonly fee: XcmV1MultiAsset;
            readonly dest: XcmV1MultiLocation;
        } & Struct;
        readonly type: 'TransferredMultiAssets';
    }
    /** @name OrmlUnknownTokensModuleEvent (104) */
    interface OrmlUnknownTokensModuleEvent extends Enum {
        readonly isDeposited: boolean;
        readonly asDeposited: {
            readonly asset: XcmV1MultiAsset;
            readonly who: XcmV1MultiLocation;
        } & Struct;
        readonly isWithdrawn: boolean;
        readonly asWithdrawn: {
            readonly asset: XcmV1MultiAsset;
            readonly who: XcmV1MultiLocation;
        } & Struct;
        readonly type: 'Deposited' | 'Withdrawn';
    }
    /** @name OrmlXcmModuleEvent (105) */
    interface OrmlXcmModuleEvent extends Enum {
        readonly isSent: boolean;
        readonly asSent: {
            readonly to: XcmV1MultiLocation;
            readonly message: XcmV2Xcm;
        } & Struct;
        readonly type: 'Sent';
    }
    /** @name OrmlAssetRegistryModuleEvent (106) */
    interface OrmlAssetRegistryModuleEvent extends Enum {
        readonly isRegisteredAsset: boolean;
        readonly asRegisteredAsset: {
            readonly assetId: u32;
            readonly metadata: OrmlTraitsAssetRegistryAssetMetadata;
        } & Struct;
        readonly isUpdatedAsset: boolean;
        readonly asUpdatedAsset: {
            readonly assetId: u32;
            readonly metadata: OrmlTraitsAssetRegistryAssetMetadata;
        } & Struct;
        readonly type: 'RegisteredAsset' | 'UpdatedAsset';
    }
    /** @name OrmlTraitsAssetRegistryAssetMetadata (107) */
    interface OrmlTraitsAssetRegistryAssetMetadata extends Struct {
        readonly decimals: u32;
        readonly name: Bytes;
        readonly symbol: Bytes;
        readonly existentialDeposit: u128;
        readonly location: Option<XcmVersionedMultiLocation>;
        readonly additional: MangataTypesAssetsCustomMetadata;
    }
    /** @name MangataTypesAssetsCustomMetadata (108) */
    interface MangataTypesAssetsCustomMetadata extends Struct {
        readonly xcm: Option<MangataTypesAssetsXcmMetadata>;
        readonly xyk: Option<MangataTypesAssetsXykMetadata>;
    }
    /** @name MangataTypesAssetsXcmMetadata (110) */
    interface MangataTypesAssetsXcmMetadata extends Struct {
        readonly feePerSecond: u128;
    }
    /** @name MangataTypesAssetsXykMetadata (112) */
    interface MangataTypesAssetsXykMetadata extends Struct {
        readonly operationsDisabled: bool;
    }
    /** @name PalletTreasuryEvent (114) */
    interface PalletTreasuryEvent extends Enum {
        readonly isProposed: boolean;
        readonly asProposed: {
            readonly proposalIndex: u32;
        } & Struct;
        readonly isSpending: boolean;
        readonly asSpending: {
            readonly budgetRemaining: u128;
        } & Struct;
        readonly isAwarded: boolean;
        readonly asAwarded: {
            readonly proposalIndex: u32;
            readonly award: u128;
            readonly account: AccountId32;
        } & Struct;
        readonly isRejected: boolean;
        readonly asRejected: {
            readonly proposalIndex: u32;
            readonly slashed: u128;
        } & Struct;
        readonly isBurnt: boolean;
        readonly asBurnt: {
            readonly burntFunds: u128;
        } & Struct;
        readonly isRollover: boolean;
        readonly asRollover: {
            readonly rolloverBalance: u128;
        } & Struct;
        readonly isDeposit: boolean;
        readonly asDeposit: {
            readonly value: u128;
        } & Struct;
        readonly isSpendApproved: boolean;
        readonly asSpendApproved: {
            readonly proposalIndex: u32;
            readonly amount: u128;
            readonly beneficiary: AccountId32;
        } & Struct;
        readonly type: 'Proposed' | 'Spending' | 'Awarded' | 'Rejected' | 'Burnt' | 'Rollover' | 'Deposit' | 'SpendApproved';
    }
    /** @name PalletSudoMangataEvent (115) */
    interface PalletSudoMangataEvent extends Enum {
        readonly isSudid: boolean;
        readonly asSudid: {
            readonly sudoResult: Result<Null, SpRuntimeDispatchError>;
        } & Struct;
        readonly isKeyChanged: boolean;
        readonly asKeyChanged: {
            readonly oldSudoer: Option<AccountId32>;
        } & Struct;
        readonly isSudoAsDone: boolean;
        readonly asSudoAsDone: {
            readonly sudoResult: Result<Null, SpRuntimeDispatchError>;
        } & Struct;
        readonly type: 'Sudid' | 'KeyChanged' | 'SudoAsDone';
    }
    /** @name PalletSudoOriginEvent (117) */
    interface PalletSudoOriginEvent extends Enum {
        readonly isSuOriginDid: boolean;
        readonly asSuOriginDid: Result<Null, SpRuntimeDispatchError>;
        readonly isSuOriginDoAsDone: boolean;
        readonly asSuOriginDoAsDone: Result<Null, SpRuntimeDispatchError>;
        readonly type: 'SuOriginDid' | 'SuOriginDoAsDone';
    }
    /** @name PalletCollectiveMangataEvent (118) */
    interface PalletCollectiveMangataEvent extends Enum {
        readonly isProposed: boolean;
        readonly asProposed: {
            readonly account: AccountId32;
            readonly proposalIndex: u32;
            readonly proposalHash: H256;
            readonly threshold: u32;
        } & Struct;
        readonly isVoted: boolean;
        readonly asVoted: {
            readonly account: AccountId32;
            readonly proposalHash: H256;
            readonly voted: bool;
            readonly yes: u32;
            readonly no: u32;
        } & Struct;
        readonly isApproved: boolean;
        readonly asApproved: {
            readonly proposalHash: H256;
        } & Struct;
        readonly isDisapproved: boolean;
        readonly asDisapproved: {
            readonly proposalHash: H256;
        } & Struct;
        readonly isExecuted: boolean;
        readonly asExecuted: {
            readonly proposalHash: H256;
            readonly result: Result<Null, SpRuntimeDispatchError>;
        } & Struct;
        readonly isMemberExecuted: boolean;
        readonly asMemberExecuted: {
            readonly proposalHash: H256;
            readonly result: Result<Null, SpRuntimeDispatchError>;
        } & Struct;
        readonly isClosed: boolean;
        readonly asClosed: {
            readonly proposalHash: H256;
            readonly yes: u32;
            readonly no: u32;
        } & Struct;
        readonly isMembersChanged: boolean;
        readonly asMembersChanged: {
            readonly newMembers: Vec<AccountId32>;
        } & Struct;
        readonly isPrimeSet: boolean;
        readonly asPrimeSet: {
            readonly newPrime: Option<AccountId32>;
        } & Struct;
        readonly type: 'Proposed' | 'Voted' | 'Approved' | 'Disapproved' | 'Executed' | 'MemberExecuted' | 'Closed' | 'MembersChanged' | 'PrimeSet';
    }
    /** @name PalletBootstrapEvent (120) */
    interface PalletBootstrapEvent extends Enum {
        readonly isProvisioned: boolean;
        readonly asProvisioned: ITuple<[u32, u128]>;
        readonly isVestedProvisioned: boolean;
        readonly asVestedProvisioned: ITuple<[u32, u128]>;
        readonly isRewardsLiquidityAcitvationFailed: boolean;
        readonly asRewardsLiquidityAcitvationFailed: ITuple<[AccountId32, u32, u128]>;
        readonly isRewardsClaimed: boolean;
        readonly asRewardsClaimed: ITuple<[u32, u128]>;
        readonly isAccountsWhitelisted: boolean;
        readonly isBootstrapParitallyFinalized: boolean;
        readonly isBootstrapFinalized: boolean;
        readonly type: 'Provisioned' | 'VestedProvisioned' | 'RewardsLiquidityAcitvationFailed' | 'RewardsClaimed' | 'AccountsWhitelisted' | 'BootstrapParitallyFinalized' | 'BootstrapFinalized';
    }
    /** @name PalletUtilityEvent (121) */
    interface PalletUtilityEvent extends Enum {
        readonly isBatchInterrupted: boolean;
        readonly asBatchInterrupted: {
            readonly index: u32;
            readonly error: SpRuntimeDispatchError;
        } & Struct;
        readonly isBatchCompleted: boolean;
        readonly isBatchCompletedWithErrors: boolean;
        readonly isItemCompleted: boolean;
        readonly isItemFailed: boolean;
        readonly asItemFailed: {
            readonly error: SpRuntimeDispatchError;
        } & Struct;
        readonly isDispatchedAs: boolean;
        readonly asDispatchedAs: {
            readonly result: Result<Null, SpRuntimeDispatchError>;
        } & Struct;
        readonly type: 'BatchInterrupted' | 'BatchCompleted' | 'BatchCompletedWithErrors' | 'ItemCompleted' | 'ItemFailed' | 'DispatchedAs';
    }
    /** @name PalletProxyEvent (122) */
    interface PalletProxyEvent extends Enum {
        readonly isProxyExecuted: boolean;
        readonly asProxyExecuted: {
            readonly result: Result<Null, SpRuntimeDispatchError>;
        } & Struct;
        readonly isPureCreated: boolean;
        readonly asPureCreated: {
            readonly pure: AccountId32;
            readonly who: AccountId32;
            readonly proxyType: MangataRococoRuntimeProxyType;
            readonly disambiguationIndex: u16;
        } & Struct;
        readonly isAnnounced: boolean;
        readonly asAnnounced: {
            readonly real: AccountId32;
            readonly proxy: AccountId32;
            readonly callHash: H256;
        } & Struct;
        readonly isProxyAdded: boolean;
        readonly asProxyAdded: {
            readonly delegator: AccountId32;
            readonly delegatee: AccountId32;
            readonly proxyType: MangataRococoRuntimeProxyType;
            readonly delay: u32;
        } & Struct;
        readonly isProxyRemoved: boolean;
        readonly asProxyRemoved: {
            readonly delegator: AccountId32;
            readonly delegatee: AccountId32;
            readonly proxyType: MangataRococoRuntimeProxyType;
            readonly delay: u32;
        } & Struct;
        readonly type: 'ProxyExecuted' | 'PureCreated' | 'Announced' | 'ProxyAdded' | 'ProxyRemoved';
    }
    /** @name MangataRococoRuntimeProxyType (123) */
    interface MangataRococoRuntimeProxyType extends Enum {
        readonly isAny: boolean;
        readonly isAutoCompound: boolean;
        readonly type: 'Any' | 'AutoCompound';
    }
    /** @name FrameSystemPhase (125) */
    interface FrameSystemPhase extends Enum {
        readonly isApplyExtrinsic: boolean;
        readonly asApplyExtrinsic: u32;
        readonly isFinalization: boolean;
        readonly isInitialization: boolean;
        readonly type: 'ApplyExtrinsic' | 'Finalization' | 'Initialization';
    }
    /** @name FrameSystemLastRuntimeUpgradeInfo (129) */
    interface FrameSystemLastRuntimeUpgradeInfo extends Struct {
        readonly specVersion: Compact<u32>;
        readonly specName: Text;
    }
    /** @name FrameSystemCall (131) */
    interface FrameSystemCall extends Enum {
        readonly isFillBlock: boolean;
        readonly asFillBlock: {
            readonly ratio: Perbill;
        } & Struct;
        readonly isEnqueueTxs: boolean;
        readonly asEnqueueTxs: {
            readonly txs: Vec<ITuple<[Option<AccountId32>, Bytes]>>;
        } & Struct;
        readonly isRemark: boolean;
        readonly asRemark: {
            readonly remark: Bytes;
        } & Struct;
        readonly isSetHeapPages: boolean;
        readonly asSetHeapPages: {
            readonly pages: u64;
        } & Struct;
        readonly isSetCode: boolean;
        readonly asSetCode: {
            readonly code: Bytes;
        } & Struct;
        readonly isSetCodeWithoutChecks: boolean;
        readonly asSetCodeWithoutChecks: {
            readonly code: Bytes;
        } & Struct;
        readonly isSetStorage: boolean;
        readonly asSetStorage: {
            readonly items: Vec<ITuple<[Bytes, Bytes]>>;
        } & Struct;
        readonly isKillStorage: boolean;
        readonly asKillStorage: {
            readonly keys_: Vec<Bytes>;
        } & Struct;
        readonly isKillPrefix: boolean;
        readonly asKillPrefix: {
            readonly prefix: Bytes;
            readonly subkeys: u32;
        } & Struct;
        readonly isRemarkWithEvent: boolean;
        readonly asRemarkWithEvent: {
            readonly remark: Bytes;
        } & Struct;
        readonly type: 'FillBlock' | 'EnqueueTxs' | 'Remark' | 'SetHeapPages' | 'SetCode' | 'SetCodeWithoutChecks' | 'SetStorage' | 'KillStorage' | 'KillPrefix' | 'RemarkWithEvent';
    }
    /** @name FrameSystemLimitsBlockWeights (135) */
    interface FrameSystemLimitsBlockWeights extends Struct {
        readonly baseBlock: SpWeightsWeightV2Weight;
        readonly maxBlock: SpWeightsWeightV2Weight;
        readonly perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
    }
    /** @name FrameSupportDispatchPerDispatchClassWeightsPerClass (136) */
    interface FrameSupportDispatchPerDispatchClassWeightsPerClass extends Struct {
        readonly normal: FrameSystemLimitsWeightsPerClass;
        readonly operational: FrameSystemLimitsWeightsPerClass;
        readonly mandatory: FrameSystemLimitsWeightsPerClass;
    }
    /** @name FrameSystemLimitsWeightsPerClass (137) */
    interface FrameSystemLimitsWeightsPerClass extends Struct {
        readonly baseExtrinsic: SpWeightsWeightV2Weight;
        readonly maxExtrinsic: Option<SpWeightsWeightV2Weight>;
        readonly maxTotal: Option<SpWeightsWeightV2Weight>;
        readonly reserved: Option<SpWeightsWeightV2Weight>;
    }
    /** @name FrameSystemLimitsBlockLength (139) */
    interface FrameSystemLimitsBlockLength extends Struct {
        readonly max: FrameSupportDispatchPerDispatchClassU32;
    }
    /** @name FrameSupportDispatchPerDispatchClassU32 (140) */
    interface FrameSupportDispatchPerDispatchClassU32 extends Struct {
        readonly normal: u32;
        readonly operational: u32;
        readonly mandatory: u32;
    }
    /** @name SpWeightsRuntimeDbWeight (141) */
    interface SpWeightsRuntimeDbWeight extends Struct {
        readonly read: u64;
        readonly write: u64;
    }
    /** @name SpVersionRuntimeVersion (142) */
    interface SpVersionRuntimeVersion extends Struct {
        readonly specName: Text;
        readonly implName: Text;
        readonly authoringVersion: u32;
        readonly specVersion: u32;
        readonly implVersion: u32;
        readonly apis: Vec<ITuple<[U8aFixed, u32]>>;
        readonly transactionVersion: u32;
        readonly stateVersion: u8;
    }
    /** @name FrameSystemError (146) */
    interface FrameSystemError extends Enum {
        readonly isInvalidSpecName: boolean;
        readonly isSpecVersionNeedsToIncrease: boolean;
        readonly isFailedToExtractRuntimeVersion: boolean;
        readonly isNonDefaultComposite: boolean;
        readonly isNonZeroRefCount: boolean;
        readonly isCallFiltered: boolean;
        readonly isStorageQueueFull: boolean;
        readonly type: 'InvalidSpecName' | 'SpecVersionNeedsToIncrease' | 'FailedToExtractRuntimeVersion' | 'NonDefaultComposite' | 'NonZeroRefCount' | 'CallFiltered' | 'StorageQueueFull';
    }
    /** @name PolkadotPrimitivesV2PersistedValidationData (147) */
    interface PolkadotPrimitivesV2PersistedValidationData extends Struct {
        readonly parentHead: Bytes;
        readonly relayParentNumber: u32;
        readonly relayParentStorageRoot: H256;
        readonly maxPovSize: u32;
    }
    /** @name PolkadotPrimitivesV2UpgradeRestriction (150) */
    interface PolkadotPrimitivesV2UpgradeRestriction extends Enum {
        readonly isPresent: boolean;
        readonly type: 'Present';
    }
    /** @name SpTrieStorageProof (151) */
    interface SpTrieStorageProof extends Struct {
        readonly trieNodes: BTreeSet<Bytes>;
    }
    /** @name CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot (153) */
    interface CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot extends Struct {
        readonly dmqMqcHead: H256;
        readonly relayDispatchQueueSize: ITuple<[u32, u32]>;
        readonly ingressChannels: Vec<ITuple<[u32, PolkadotPrimitivesV2AbridgedHrmpChannel]>>;
        readonly egressChannels: Vec<ITuple<[u32, PolkadotPrimitivesV2AbridgedHrmpChannel]>>;
    }
    /** @name PolkadotPrimitivesV2AbridgedHrmpChannel (156) */
    interface PolkadotPrimitivesV2AbridgedHrmpChannel extends Struct {
        readonly maxCapacity: u32;
        readonly maxTotalSize: u32;
        readonly maxMessageSize: u32;
        readonly msgCount: u32;
        readonly totalSize: u32;
        readonly mqcHead: Option<H256>;
    }
    /** @name PolkadotPrimitivesV2AbridgedHostConfiguration (157) */
    interface PolkadotPrimitivesV2AbridgedHostConfiguration extends Struct {
        readonly maxCodeSize: u32;
        readonly maxHeadDataSize: u32;
        readonly maxUpwardQueueCount: u32;
        readonly maxUpwardQueueSize: u32;
        readonly maxUpwardMessageSize: u32;
        readonly maxUpwardMessageNumPerCandidate: u32;
        readonly hrmpMaxMessageNumPerCandidate: u32;
        readonly validationUpgradeCooldown: u32;
        readonly validationUpgradeDelay: u32;
    }
    /** @name PolkadotCorePrimitivesOutboundHrmpMessage (163) */
    interface PolkadotCorePrimitivesOutboundHrmpMessage extends Struct {
        readonly recipient: u32;
        readonly data: Bytes;
    }
    /** @name CumulusPalletParachainSystemCall (164) */
    interface CumulusPalletParachainSystemCall extends Enum {
        readonly isSetValidationData: boolean;
        readonly asSetValidationData: {
            readonly data: CumulusPrimitivesParachainInherentParachainInherentData;
        } & Struct;
        readonly isSudoSendUpwardMessage: boolean;
        readonly asSudoSendUpwardMessage: {
            readonly message: Bytes;
        } & Struct;
        readonly isAuthorizeUpgrade: boolean;
        readonly asAuthorizeUpgrade: {
            readonly codeHash: H256;
        } & Struct;
        readonly isEnactAuthorizedUpgrade: boolean;
        readonly asEnactAuthorizedUpgrade: {
            readonly code: Bytes;
        } & Struct;
        readonly type: 'SetValidationData' | 'SudoSendUpwardMessage' | 'AuthorizeUpgrade' | 'EnactAuthorizedUpgrade';
    }
    /** @name CumulusPrimitivesParachainInherentParachainInherentData (165) */
    interface CumulusPrimitivesParachainInherentParachainInherentData extends Struct {
        readonly validationData: PolkadotPrimitivesV2PersistedValidationData;
        readonly relayChainState: SpTrieStorageProof;
        readonly downwardMessages: Vec<PolkadotCorePrimitivesInboundDownwardMessage>;
        readonly horizontalMessages: BTreeMap<u32, Vec<PolkadotCorePrimitivesInboundHrmpMessage>>;
    }
    /** @name PolkadotCorePrimitivesInboundDownwardMessage (167) */
    interface PolkadotCorePrimitivesInboundDownwardMessage extends Struct {
        readonly sentAt: u32;
        readonly msg: Bytes;
    }
    /** @name PolkadotCorePrimitivesInboundHrmpMessage (170) */
    interface PolkadotCorePrimitivesInboundHrmpMessage extends Struct {
        readonly sentAt: u32;
        readonly data: Bytes;
    }
    /** @name CumulusPalletParachainSystemError (173) */
    interface CumulusPalletParachainSystemError extends Enum {
        readonly isOverlappingUpgrades: boolean;
        readonly isProhibitedByPolkadot: boolean;
        readonly isTooBig: boolean;
        readonly isValidationDataNotAvailable: boolean;
        readonly isHostConfigurationNotAvailable: boolean;
        readonly isNotScheduled: boolean;
        readonly isNothingAuthorized: boolean;
        readonly isUnauthorized: boolean;
        readonly type: 'OverlappingUpgrades' | 'ProhibitedByPolkadot' | 'TooBig' | 'ValidationDataNotAvailable' | 'HostConfigurationNotAvailable' | 'NotScheduled' | 'NothingAuthorized' | 'Unauthorized';
    }
    /** @name PalletTimestampCall (174) */
    interface PalletTimestampCall extends Enum {
        readonly isSet: boolean;
        readonly asSet: {
            readonly now: Compact<u64>;
        } & Struct;
        readonly type: 'Set';
    }
    /** @name OrmlTokensBalanceLock (177) */
    interface OrmlTokensBalanceLock extends Struct {
        readonly id: U8aFixed;
        readonly amount: u128;
    }
    /** @name OrmlTokensAccountData (179) */
    interface OrmlTokensAccountData extends Struct {
        readonly free: u128;
        readonly reserved: u128;
        readonly frozen: u128;
    }
    /** @name OrmlTokensReserveData (181) */
    interface OrmlTokensReserveData extends Struct {
        readonly id: U8aFixed;
        readonly amount: u128;
    }
    /** @name OrmlTokensModuleCall (183) */
    interface OrmlTokensModuleCall extends Enum {
        readonly isTransfer: boolean;
        readonly asTransfer: {
            readonly dest: MultiAddress;
            readonly currencyId: u32;
            readonly amount: Compact<u128>;
        } & Struct;
        readonly isTransferAll: boolean;
        readonly asTransferAll: {
            readonly dest: MultiAddress;
            readonly currencyId: u32;
            readonly keepAlive: bool;
        } & Struct;
        readonly isTransferKeepAlive: boolean;
        readonly asTransferKeepAlive: {
            readonly dest: MultiAddress;
            readonly currencyId: u32;
            readonly amount: Compact<u128>;
        } & Struct;
        readonly isForceTransfer: boolean;
        readonly asForceTransfer: {
            readonly source: MultiAddress;
            readonly dest: MultiAddress;
            readonly currencyId: u32;
            readonly amount: Compact<u128>;
        } & Struct;
        readonly isSetBalance: boolean;
        readonly asSetBalance: {
            readonly who: MultiAddress;
            readonly currencyId: u32;
            readonly newFree: Compact<u128>;
            readonly newReserved: Compact<u128>;
        } & Struct;
        readonly isCreate: boolean;
        readonly asCreate: {
            readonly who: MultiAddress;
            readonly amount: Compact<u128>;
        } & Struct;
        readonly isMint: boolean;
        readonly asMint: {
            readonly currencyId: u32;
            readonly who: MultiAddress;
            readonly amount: Compact<u128>;
        } & Struct;
        readonly type: 'Transfer' | 'TransferAll' | 'TransferKeepAlive' | 'ForceTransfer' | 'SetBalance' | 'Create' | 'Mint';
    }
    /** @name OrmlTokensModuleError (186) */
    interface OrmlTokensModuleError extends Enum {
        readonly isBalanceTooLow: boolean;
        readonly isAmountIntoBalanceFailed: boolean;
        readonly isLiquidityRestrictions: boolean;
        readonly isMaxLocksExceeded: boolean;
        readonly isKeepAlive: boolean;
        readonly isExistentialDeposit: boolean;
        readonly isDeadAccount: boolean;
        readonly isTokenIdNotExists: boolean;
        readonly isTooManyReserves: boolean;
        readonly type: 'BalanceTooLow' | 'AmountIntoBalanceFailed' | 'LiquidityRestrictions' | 'MaxLocksExceeded' | 'KeepAlive' | 'ExistentialDeposit' | 'DeadAccount' | 'TokenIdNotExists' | 'TooManyReserves';
    }
    /** @name PalletTransactionPaymentReleases (188) */
    interface PalletTransactionPaymentReleases extends Enum {
        readonly isV1Ancient: boolean;
        readonly isV2: boolean;
        readonly type: 'V1Ancient' | 'V2';
    }
    /** @name PalletXykRewardInfo (191) */
    interface PalletXykRewardInfo extends Struct {
        readonly activatedAmount: u128;
        readonly rewardsNotYetClaimed: u128;
        readonly rewardsAlreadyClaimed: u128;
        readonly lastCheckpoint: u32;
        readonly poolRatioAtLastCheckpoint: U256;
        readonly missingAtLastCheckpoint: U256;
    }
    /** @name PalletXykCall (195) */
    interface PalletXykCall extends Enum {
        readonly isCreatePool: boolean;
        readonly asCreatePool: {
            readonly firstAssetId: u32;
            readonly firstAssetAmount: u128;
            readonly secondAssetId: u32;
            readonly secondAssetAmount: u128;
        } & Struct;
        readonly isSellAsset: boolean;
        readonly asSellAsset: {
            readonly soldAssetId: u32;
            readonly boughtAssetId: u32;
            readonly soldAssetAmount: u128;
            readonly minAmountOut: u128;
        } & Struct;
        readonly isBuyAsset: boolean;
        readonly asBuyAsset: {
            readonly soldAssetId: u32;
            readonly boughtAssetId: u32;
            readonly boughtAssetAmount: u128;
            readonly maxAmountIn: u128;
        } & Struct;
        readonly isMintLiquidityUsingVestingNativeTokensByVestingIndex: boolean;
        readonly asMintLiquidityUsingVestingNativeTokensByVestingIndex: {
            readonly nativeAssetVestingIndex: u32;
            readonly vestingNativeAssetUnlockSomeAmountOrAll: Option<u128>;
            readonly secondAssetId: u32;
            readonly expectedSecondAssetAmount: u128;
        } & Struct;
        readonly isMintLiquidityUsingVestingNativeTokens: boolean;
        readonly asMintLiquidityUsingVestingNativeTokens: {
            readonly vestingNativeAssetAmount: u128;
            readonly secondAssetId: u32;
            readonly expectedSecondAssetAmount: u128;
        } & Struct;
        readonly isMintLiquidity: boolean;
        readonly asMintLiquidity: {
            readonly firstAssetId: u32;
            readonly secondAssetId: u32;
            readonly firstAssetAmount: u128;
            readonly expectedSecondAssetAmount: u128;
        } & Struct;
        readonly isCompoundRewards: boolean;
        readonly asCompoundRewards: {
            readonly liquidityAssetId: u32;
            readonly amountPermille: Permill;
        } & Struct;
        readonly isProvideLiquidityWithConversion: boolean;
        readonly asProvideLiquidityWithConversion: {
            readonly liquidityAssetId: u32;
            readonly providedAssetId: u32;
            readonly providedAssetAmount: u128;
        } & Struct;
        readonly isBurnLiquidity: boolean;
        readonly asBurnLiquidity: {
            readonly firstAssetId: u32;
            readonly secondAssetId: u32;
            readonly liquidityAssetAmount: u128;
        } & Struct;
        readonly isClaimRewardsV2: boolean;
        readonly asClaimRewardsV2: {
            readonly liquidityTokenId: u32;
            readonly amount: u128;
        } & Struct;
        readonly isClaimRewardsAllV2: boolean;
        readonly asClaimRewardsAllV2: {
            readonly liquidityTokenId: u32;
        } & Struct;
        readonly isUpdatePoolPromotion: boolean;
        readonly asUpdatePoolPromotion: {
            readonly liquidityTokenId: u32;
            readonly liquidityMiningIssuanceWeight: Option<u8>;
        } & Struct;
        readonly isActivateLiquidityV2: boolean;
        readonly asActivateLiquidityV2: {
            readonly liquidityTokenId: u32;
            readonly amount: u128;
            readonly useBalanceFrom: Option<MpMultipurposeLiquidityActivateKind>;
        } & Struct;
        readonly isDeactivateLiquidityV2: boolean;
        readonly asDeactivateLiquidityV2: {
            readonly liquidityTokenId: u32;
            readonly amount: u128;
        } & Struct;
        readonly isRewardsMigrateV1ToV2: boolean;
        readonly asRewardsMigrateV1ToV2: {
            readonly account: AccountId32;
            readonly liquidityTokenId: u32;
        } & Struct;
        readonly type: 'CreatePool' | 'SellAsset' | 'BuyAsset' | 'MintLiquidityUsingVestingNativeTokensByVestingIndex' | 'MintLiquidityUsingVestingNativeTokens' | 'MintLiquidity' | 'CompoundRewards' | 'ProvideLiquidityWithConversion' | 'BurnLiquidity' | 'ClaimRewardsV2' | 'ClaimRewardsAllV2' | 'UpdatePoolPromotion' | 'ActivateLiquidityV2' | 'DeactivateLiquidityV2' | 'RewardsMigrateV1ToV2';
    }
    /** @name MpMultipurposeLiquidityActivateKind (199) */
    interface MpMultipurposeLiquidityActivateKind extends Enum {
        readonly isAvailableBalance: boolean;
        readonly isStakedUnactivatedReserves: boolean;
        readonly isUnspentReserves: boolean;
        readonly type: 'AvailableBalance' | 'StakedUnactivatedReserves' | 'UnspentReserves';
    }
    /** @name PalletXykError (200) */
    interface PalletXykError extends Enum {
        readonly isPoolAlreadyExists: boolean;
        readonly isNotEnoughAssets: boolean;
        readonly isNoSuchPool: boolean;
        readonly isNoSuchLiquidityAsset: boolean;
        readonly isNotEnoughReserve: boolean;
        readonly isZeroAmount: boolean;
        readonly isInsufficientInputAmount: boolean;
        readonly isInsufficientOutputAmount: boolean;
        readonly isSameAsset: boolean;
        readonly isAssetAlreadyExists: boolean;
        readonly isAssetDoesNotExists: boolean;
        readonly isDivisionByZero: boolean;
        readonly isUnexpectedFailure: boolean;
        readonly isNotMangataLiquidityAsset: boolean;
        readonly isSecondAssetAmountExceededExpectations: boolean;
        readonly isMathOverflow: boolean;
        readonly isLiquidityTokenCreationFailed: boolean;
        readonly isNotEnoughRewardsEarned: boolean;
        readonly isNotAPromotedPool: boolean;
        readonly isPastTimeCalculation: boolean;
        readonly isPoolAlreadyPromoted: boolean;
        readonly isSoldAmountTooLow: boolean;
        readonly isFunctionNotAvailableForThisToken: boolean;
        readonly isDisallowedPool: boolean;
        readonly isLiquidityCheckpointMathError: boolean;
        readonly isCalculateRewardsMathError: boolean;
        readonly isCalculateCumulativeWorkMaxRatioMathError: boolean;
        readonly isCalculateRewardsAllMathError: boolean;
        readonly isNoRights: boolean;
        readonly type: 'PoolAlreadyExists' | 'NotEnoughAssets' | 'NoSuchPool' | 'NoSuchLiquidityAsset' | 'NotEnoughReserve' | 'ZeroAmount' | 'InsufficientInputAmount' | 'InsufficientOutputAmount' | 'SameAsset' | 'AssetAlreadyExists' | 'AssetDoesNotExists' | 'DivisionByZero' | 'UnexpectedFailure' | 'NotMangataLiquidityAsset' | 'SecondAssetAmountExceededExpectations' | 'MathOverflow' | 'LiquidityTokenCreationFailed' | 'NotEnoughRewardsEarned' | 'NotAPromotedPool' | 'PastTimeCalculation' | 'PoolAlreadyPromoted' | 'SoldAmountTooLow' | 'FunctionNotAvailableForThisToken' | 'DisallowedPool' | 'LiquidityCheckpointMathError' | 'CalculateRewardsMathError' | 'CalculateCumulativeWorkMaxRatioMathError' | 'CalculateRewardsAllMathError' | 'NoRights';
    }
    /** @name PalletTokenTimeoutTimeoutMetadataInfo (201) */
    interface PalletTokenTimeoutTimeoutMetadataInfo extends Struct {
        readonly periodLength: u32;
        readonly timeoutAmount: u128;
        readonly swapValueThreshold: BTreeMap<u32, u128>;
    }
    /** @name PalletTokenTimeoutAccountTimeoutDataInfo (206) */
    interface PalletTokenTimeoutAccountTimeoutDataInfo extends Struct {
        readonly totalTimeoutAmount: u128;
        readonly lastTimeoutBlock: u32;
    }
    /** @name PalletTokenTimeoutCall (207) */
    interface PalletTokenTimeoutCall extends Enum {
        readonly isUpdateTimeoutMetadata: boolean;
        readonly asUpdateTimeoutMetadata: {
            readonly periodLength: Option<u32>;
            readonly timeoutAmount: Option<u128>;
            readonly swapValueThresholds: Option<Vec<ITuple<[u32, Option<u128>]>>>;
        } & Struct;
        readonly isReleaseTimeout: boolean;
        readonly type: 'UpdateTimeoutMetadata' | 'ReleaseTimeout';
    }
    /** @name PalletTokenTimeoutError (211) */
    interface PalletTokenTimeoutError extends Enum {
        readonly isTimeoutsIncorrectlyInitialzed: boolean;
        readonly isInvalidTimeoutMetadata: boolean;
        readonly isTimeoutsNotInitialized: boolean;
        readonly isNotTimedout: boolean;
        readonly isCantReleaseYet: boolean;
        readonly isMaxCuratedTokensLimitExceeded: boolean;
        readonly isUnexpectedFailure: boolean;
        readonly type: 'TimeoutsIncorrectlyInitialzed' | 'InvalidTimeoutMetadata' | 'TimeoutsNotInitialized' | 'NotTimedout' | 'CantReleaseYet' | 'MaxCuratedTokensLimitExceeded' | 'UnexpectedFailure';
    }
    /** @name PalletVestingMangataVestingInfo (213) */
    interface PalletVestingMangataVestingInfo extends Struct {
        readonly locked: u128;
        readonly perBlock: u128;
        readonly startingBlock: u32;
    }
    /** @name PalletVestingMangataReleases (215) */
    interface PalletVestingMangataReleases extends Enum {
        readonly isV0: boolean;
        readonly isV1: boolean;
        readonly type: 'V0' | 'V1';
    }
    /** @name PalletVestingMangataCall (216) */
    interface PalletVestingMangataCall extends Enum {
        readonly isVest: boolean;
        readonly asVest: {
            readonly tokenId: u32;
        } & Struct;
        readonly isVestOther: boolean;
        readonly asVestOther: {
            readonly tokenId: u32;
            readonly target: MultiAddress;
        } & Struct;
        readonly isForceVestedTransfer: boolean;
        readonly asForceVestedTransfer: {
            readonly tokenId: u32;
            readonly source: MultiAddress;
            readonly target: MultiAddress;
            readonly schedule: PalletVestingMangataVestingInfo;
        } & Struct;
        readonly isMergeSchedules: boolean;
        readonly asMergeSchedules: {
            readonly tokenId: u32;
            readonly schedule1Index: u32;
            readonly schedule2Index: u32;
        } & Struct;
        readonly isSudoUnlockAllVestingTokens: boolean;
        readonly asSudoUnlockAllVestingTokens: {
            readonly target: MultiAddress;
            readonly tokenId: u32;
        } & Struct;
        readonly type: 'Vest' | 'VestOther' | 'ForceVestedTransfer' | 'MergeSchedules' | 'SudoUnlockAllVestingTokens';
    }
    /** @name PalletVestingMangataError (217) */
    interface PalletVestingMangataError extends Enum {
        readonly isNotVesting: boolean;
        readonly isAtMaxVestingSchedules: boolean;
        readonly isAmountLow: boolean;
        readonly isScheduleIndexOutOfBounds: boolean;
        readonly isInvalidScheduleParams: boolean;
        readonly isNoSuitableScheduleFound: boolean;
        readonly isSudoUnlockIsDisallowed: boolean;
        readonly isInvalidVestingIndex: boolean;
        readonly isMathError: boolean;
        readonly type: 'NotVesting' | 'AtMaxVestingSchedules' | 'AmountLow' | 'ScheduleIndexOutOfBounds' | 'InvalidScheduleParams' | 'NoSuitableScheduleFound' | 'SudoUnlockIsDisallowed' | 'InvalidVestingIndex' | 'MathError';
    }
    /** @name PalletCrowdloanRewardsRewardInfo (218) */
    interface PalletCrowdloanRewardsRewardInfo extends Struct {
        readonly totalReward: u128;
        readonly claimedReward: u128;
        readonly contributedRelayAddresses: Vec<AccountId32>;
    }
    /** @name PalletCrowdloanRewardsCall (219) */
    interface PalletCrowdloanRewardsCall extends Enum {
        readonly isAssociateNativeIdentity: boolean;
        readonly asAssociateNativeIdentity: {
            readonly rewardAccount: AccountId32;
            readonly relayAccount: AccountId32;
            readonly proof: SpRuntimeMultiSignature;
        } & Struct;
        readonly isChangeAssociationWithRelayKeys: boolean;
        readonly asChangeAssociationWithRelayKeys: {
            readonly rewardAccount: AccountId32;
            readonly previousAccount: AccountId32;
            readonly proofs: Vec<ITuple<[AccountId32, SpRuntimeMultiSignature]>>;
        } & Struct;
        readonly isClaim: boolean;
        readonly isUpdateRewardAddress: boolean;
        readonly asUpdateRewardAddress: {
            readonly newRewardAccount: AccountId32;
        } & Struct;
        readonly isCompleteInitialization: boolean;
        readonly asCompleteInitialization: {
            readonly leaseEndingBlock: u32;
        } & Struct;
        readonly isSetCrowdloanAllocation: boolean;
        readonly asSetCrowdloanAllocation: {
            readonly crowdloanAllocationAmount: u128;
        } & Struct;
        readonly isInitializeRewardVec: boolean;
        readonly asInitializeRewardVec: {
            readonly rewards: Vec<ITuple<[AccountId32, Option<AccountId32>, u128]>>;
        } & Struct;
        readonly type: 'AssociateNativeIdentity' | 'ChangeAssociationWithRelayKeys' | 'Claim' | 'UpdateRewardAddress' | 'CompleteInitialization' | 'SetCrowdloanAllocation' | 'InitializeRewardVec';
    }
    /** @name SpRuntimeMultiSignature (220) */
    interface SpRuntimeMultiSignature extends Enum {
        readonly isEd25519: boolean;
        readonly asEd25519: SpCoreEd25519Signature;
        readonly isSr25519: boolean;
        readonly asSr25519: SpCoreSr25519Signature;
        readonly isEcdsa: boolean;
        readonly asEcdsa: SpCoreEcdsaSignature;
        readonly type: 'Ed25519' | 'Sr25519' | 'Ecdsa';
    }
    /** @name SpCoreEd25519Signature (221) */
    interface SpCoreEd25519Signature extends U8aFixed {
    }
    /** @name SpCoreSr25519Signature (223) */
    interface SpCoreSr25519Signature extends U8aFixed {
    }
    /** @name SpCoreEcdsaSignature (224) */
    interface SpCoreEcdsaSignature extends U8aFixed {
    }
    /** @name PalletCrowdloanRewardsError (230) */
    interface PalletCrowdloanRewardsError extends Enum {
        readonly isAlreadyAssociated: boolean;
        readonly isBatchBeyondFundPot: boolean;
        readonly isFirstClaimAlreadyDone: boolean;
        readonly isRewardNotHighEnough: boolean;
        readonly isInvalidClaimSignature: boolean;
        readonly isInvalidFreeClaimSignature: boolean;
        readonly isNoAssociatedClaim: boolean;
        readonly isRewardsAlreadyClaimed: boolean;
        readonly isRewardVecAlreadyInitialized: boolean;
        readonly isRewardVecNotFullyInitializedYet: boolean;
        readonly isRewardsDoNotMatchFund: boolean;
        readonly isTooManyContributors: boolean;
        readonly isVestingPeriodNonValid: boolean;
        readonly isNonContributedAddressProvided: boolean;
        readonly isInsufficientNumberOfValidProofs: boolean;
        readonly isClaimingLessThanED: boolean;
        readonly type: 'AlreadyAssociated' | 'BatchBeyondFundPot' | 'FirstClaimAlreadyDone' | 'RewardNotHighEnough' | 'InvalidClaimSignature' | 'InvalidFreeClaimSignature' | 'NoAssociatedClaim' | 'RewardsAlreadyClaimed' | 'RewardVecAlreadyInitialized' | 'RewardVecNotFullyInitializedYet' | 'RewardsDoNotMatchFund' | 'TooManyContributors' | 'VestingPeriodNonValid' | 'NonContributedAddressProvided' | 'InsufficientNumberOfValidProofs' | 'ClaimingLessThanED';
    }
    /** @name PalletIssuancePromotedPoolsRewardsInfo (233) */
    interface PalletIssuancePromotedPoolsRewardsInfo extends Struct {
        readonly weight: u8;
        readonly rewards: U256;
    }
    /** @name PalletIssuanceCall (236) */
    interface PalletIssuanceCall extends Enum {
        readonly isInitIssuanceConfig: boolean;
        readonly isFinalizeTge: boolean;
        readonly isExecuteTge: boolean;
        readonly asExecuteTge: {
            readonly tgeInfos: Vec<PalletIssuanceTgeInfo>;
        } & Struct;
        readonly type: 'InitIssuanceConfig' | 'FinalizeTge' | 'ExecuteTge';
    }
    /** @name PalletIssuanceError (239) */
    interface PalletIssuanceError extends Enum {
        readonly isIssuanceConfigAlreadyInitialized: boolean;
        readonly isIssuanceConfigNotInitialized: boolean;
        readonly isTgeNotFinalized: boolean;
        readonly isTgeIsAlreadyFinalized: boolean;
        readonly isIssuanceConfigInvalid: boolean;
        readonly isMathError: boolean;
        readonly isUnknownPool: boolean;
        readonly type: 'IssuanceConfigAlreadyInitialized' | 'IssuanceConfigNotInitialized' | 'TgeNotFinalized' | 'TgeIsAlreadyFinalized' | 'IssuanceConfigInvalid' | 'MathError' | 'UnknownPool';
    }
    /** @name PalletAuthorshipUncleEntryItem (241) */
    interface PalletAuthorshipUncleEntryItem extends Enum {
        readonly isInclusionHeight: boolean;
        readonly asInclusionHeight: u32;
        readonly isUncle: boolean;
        readonly asUncle: ITuple<[H256, Option<AccountId32>]>;
        readonly type: 'InclusionHeight' | 'Uncle';
    }
    /** @name PalletAuthorshipCall (243) */
    interface PalletAuthorshipCall extends Enum {
        readonly isSetUncles: boolean;
        readonly asSetUncles: {
            readonly newUncles: Vec<SpRuntimeHeaderVerHeader>;
        } & Struct;
        readonly type: 'SetUncles';
    }
    /** @name SpRuntimeHeaderVerHeader (245) */
    interface SpRuntimeHeaderVerHeader extends Struct {
        readonly parentHash: H256;
        readonly number: Compact<u32>;
        readonly stateRoot: H256;
        readonly extrinsicsRoot: H256;
        readonly digest: SpRuntimeDigest;
        readonly seed: SpCoreSeedShufflingSeed;
        readonly count: u32;
    }
    /** @name SpRuntimeBlakeTwo256 (246) */
    type SpRuntimeBlakeTwo256 = Null;
    /** @name SpCoreSeedShufflingSeed (247) */
    interface SpCoreSeedShufflingSeed extends Struct {
        readonly seed: H256;
        readonly proof: H512;
    }
    /** @name PalletAuthorshipError (249) */
    interface PalletAuthorshipError extends Enum {
        readonly isInvalidUncleParent: boolean;
        readonly isUnclesAlreadySet: boolean;
        readonly isTooManyUncles: boolean;
        readonly isGenesisUncle: boolean;
        readonly isTooHighUncle: boolean;
        readonly isUncleAlreadyIncluded: boolean;
        readonly isOldUncle: boolean;
        readonly type: 'InvalidUncleParent' | 'UnclesAlreadySet' | 'TooManyUncles' | 'GenesisUncle' | 'TooHighUncle' | 'UncleAlreadyIncluded' | 'OldUncle';
    }
    /** @name ParachainStakingRoundInfo (250) */
    interface ParachainStakingRoundInfo extends Struct {
        readonly current: u32;
        readonly first: u32;
        readonly length: u32;
    }
    /** @name ParachainStakingDelegator (251) */
    interface ParachainStakingDelegator extends Struct {
        readonly id: AccountId32;
        readonly delegations: ParachainStakingSetOrderedSetBond;
        readonly requests: ParachainStakingPendingDelegationRequests;
        readonly status: ParachainStakingDelegatorStatus;
    }
    /** @name ParachainStakingSetOrderedSetBond (252) */
    interface ParachainStakingSetOrderedSetBond extends Vec<ParachainStakingBond> {
    }
    /** @name ParachainStakingBond (253) */
    interface ParachainStakingBond extends Struct {
        readonly owner: AccountId32;
        readonly amount: u128;
        readonly liquidityToken: u32;
    }
    /** @name ParachainStakingPendingDelegationRequests (255) */
    interface ParachainStakingPendingDelegationRequests extends Struct {
        readonly requests: BTreeMap<AccountId32, ParachainStakingDelegationRequest>;
    }
    /** @name ParachainStakingDelegatorStatus (259) */
    interface ParachainStakingDelegatorStatus extends Enum {
        readonly isActive: boolean;
        readonly isLeaving: boolean;
        readonly asLeaving: u32;
        readonly type: 'Active' | 'Leaving';
    }
    /** @name ParachainStakingCollatorCandidate (260) */
    interface ParachainStakingCollatorCandidate extends Struct {
        readonly id: AccountId32;
        readonly bond: u128;
        readonly liquidityToken: u32;
        readonly delegators: ParachainStakingSetOrderedSetAccountId32;
        readonly topDelegations: Vec<ParachainStakingBond>;
        readonly bottomDelegations: Vec<ParachainStakingBond>;
        readonly totalCounted: u128;
        readonly totalBacking: u128;
        readonly request: Option<ParachainStakingCandidateBondRequest>;
        readonly state: ParachainStakingCollatorStatus;
    }
    /** @name ParachainStakingSetOrderedSetAccountId32 (261) */
    interface ParachainStakingSetOrderedSetAccountId32 extends Vec<AccountId32> {
    }
    /** @name ParachainStakingCollatorStatus (263) */
    interface ParachainStakingCollatorStatus extends Enum {
        readonly isActive: boolean;
        readonly isIdle: boolean;
        readonly isLeaving: boolean;
        readonly asLeaving: u32;
        readonly type: 'Active' | 'Idle' | 'Leaving';
    }
    /** @name ParachainStakingCollatorSnapshot (265) */
    interface ParachainStakingCollatorSnapshot extends Struct {
        readonly bond: u128;
        readonly delegations: Vec<ParachainStakingBond>;
        readonly total: u128;
        readonly liquidityToken: u32;
    }
    /** @name ParachainStakingCall (269) */
    interface ParachainStakingCall extends Enum {
        readonly isSetTotalSelected: boolean;
        readonly asSetTotalSelected: {
            readonly new_: u32;
        } & Struct;
        readonly isSetCollatorCommission: boolean;
        readonly asSetCollatorCommission: {
            readonly new_: Perbill;
        } & Struct;
        readonly isJoinCandidates: boolean;
        readonly asJoinCandidates: {
            readonly bond: u128;
            readonly liquidityToken: u32;
            readonly useBalanceFrom: Option<MpMultipurposeLiquidityBondKind>;
            readonly candidateCount: u32;
            readonly liquidityTokenCount: u32;
        } & Struct;
        readonly isScheduleLeaveCandidates: boolean;
        readonly asScheduleLeaveCandidates: {
            readonly candidateCount: u32;
        } & Struct;
        readonly isExecuteLeaveCandidates: boolean;
        readonly asExecuteLeaveCandidates: {
            readonly candidate: AccountId32;
            readonly candidateDelegationCount: u32;
        } & Struct;
        readonly isCancelLeaveCandidates: boolean;
        readonly asCancelLeaveCandidates: {
            readonly candidateCount: u32;
        } & Struct;
        readonly isGoOffline: boolean;
        readonly isGoOnline: boolean;
        readonly isScheduleCandidateBondMore: boolean;
        readonly asScheduleCandidateBondMore: {
            readonly more: u128;
            readonly useBalanceFrom: Option<MpMultipurposeLiquidityBondKind>;
        } & Struct;
        readonly isScheduleCandidateBondLess: boolean;
        readonly asScheduleCandidateBondLess: {
            readonly less: u128;
        } & Struct;
        readonly isExecuteCandidateBondRequest: boolean;
        readonly asExecuteCandidateBondRequest: {
            readonly candidate: AccountId32;
            readonly useBalanceFrom: Option<MpMultipurposeLiquidityBondKind>;
        } & Struct;
        readonly isCancelCandidateBondRequest: boolean;
        readonly isDelegate: boolean;
        readonly asDelegate: {
            readonly collator: AccountId32;
            readonly amount: u128;
            readonly useBalanceFrom: Option<MpMultipurposeLiquidityBondKind>;
            readonly candidateDelegationCount: u32;
            readonly delegationCount: u32;
        } & Struct;
        readonly isScheduleLeaveDelegators: boolean;
        readonly isExecuteLeaveDelegators: boolean;
        readonly asExecuteLeaveDelegators: {
            readonly delegator: AccountId32;
            readonly delegationCount: u32;
        } & Struct;
        readonly isCancelLeaveDelegators: boolean;
        readonly isScheduleRevokeDelegation: boolean;
        readonly asScheduleRevokeDelegation: {
            readonly collator: AccountId32;
        } & Struct;
        readonly isScheduleDelegatorBondMore: boolean;
        readonly asScheduleDelegatorBondMore: {
            readonly candidate: AccountId32;
            readonly more: u128;
            readonly useBalanceFrom: Option<MpMultipurposeLiquidityBondKind>;
        } & Struct;
        readonly isScheduleDelegatorBondLess: boolean;
        readonly asScheduleDelegatorBondLess: {
            readonly candidate: AccountId32;
            readonly less: u128;
        } & Struct;
        readonly isExecuteDelegationRequest: boolean;
        readonly asExecuteDelegationRequest: {
            readonly delegator: AccountId32;
            readonly candidate: AccountId32;
            readonly useBalanceFrom: Option<MpMultipurposeLiquidityBondKind>;
        } & Struct;
        readonly isCancelDelegationRequest: boolean;
        readonly asCancelDelegationRequest: {
            readonly candidate: AccountId32;
        } & Struct;
        readonly isAddStakingLiquidityToken: boolean;
        readonly asAddStakingLiquidityToken: {
            readonly pairedOrLiquidityToken: ParachainStakingPairedOrLiquidityToken;
            readonly currentLiquidityTokens: u32;
        } & Struct;
        readonly isRemoveStakingLiquidityToken: boolean;
        readonly asRemoveStakingLiquidityToken: {
            readonly pairedOrLiquidityToken: ParachainStakingPairedOrLiquidityToken;
            readonly currentLiquidityTokens: u32;
        } & Struct;
        readonly type: 'SetTotalSelected' | 'SetCollatorCommission' | 'JoinCandidates' | 'ScheduleLeaveCandidates' | 'ExecuteLeaveCandidates' | 'CancelLeaveCandidates' | 'GoOffline' | 'GoOnline' | 'ScheduleCandidateBondMore' | 'ScheduleCandidateBondLess' | 'ExecuteCandidateBondRequest' | 'CancelCandidateBondRequest' | 'Delegate' | 'ScheduleLeaveDelegators' | 'ExecuteLeaveDelegators' | 'CancelLeaveDelegators' | 'ScheduleRevokeDelegation' | 'ScheduleDelegatorBondMore' | 'ScheduleDelegatorBondLess' | 'ExecuteDelegationRequest' | 'CancelDelegationRequest' | 'AddStakingLiquidityToken' | 'RemoveStakingLiquidityToken';
    }
    /** @name MpMultipurposeLiquidityBondKind (271) */
    interface MpMultipurposeLiquidityBondKind extends Enum {
        readonly isAvailableBalance: boolean;
        readonly isActivatedUnstakedReserves: boolean;
        readonly isUnspentReserves: boolean;
        readonly type: 'AvailableBalance' | 'ActivatedUnstakedReserves' | 'UnspentReserves';
    }
    /** @name ParachainStakingPairedOrLiquidityToken (272) */
    interface ParachainStakingPairedOrLiquidityToken extends Enum {
        readonly isPaired: boolean;
        readonly asPaired: u32;
        readonly isLiquidity: boolean;
        readonly asLiquidity: u32;
        readonly type: 'Paired' | 'Liquidity';
    }
    /** @name ParachainStakingError (273) */
    interface ParachainStakingError extends Enum {
        readonly isDelegatorDNE: boolean;
        readonly isDelegatorDNEinTopNorBottom: boolean;
        readonly isDelegatorDNEInDelegatorSet: boolean;
        readonly isCandidateDNE: boolean;
        readonly isDelegationDNE: boolean;
        readonly isDelegatorExists: boolean;
        readonly isCandidateExists: boolean;
        readonly isCandidateBondBelowMin: boolean;
        readonly isInsufficientBalance: boolean;
        readonly isDelegationBelowMin: boolean;
        readonly isAlreadyOffline: boolean;
        readonly isAlreadyActive: boolean;
        readonly isDelegatorAlreadyLeaving: boolean;
        readonly isDelegatorNotLeaving: boolean;
        readonly isDelegatorCannotLeaveYet: boolean;
        readonly isCannotDelegateIfLeaving: boolean;
        readonly isCandidateAlreadyLeaving: boolean;
        readonly isCandidateNotLeaving: boolean;
        readonly isCandidateCannotLeaveYet: boolean;
        readonly isCannotGoOnlineIfLeaving: boolean;
        readonly isExceedMaxDelegationsPerDelegator: boolean;
        readonly isAlreadyDelegatedCandidate: boolean;
        readonly isInvalidSchedule: boolean;
        readonly isCannotSetBelowMin: boolean;
        readonly isNoWritingSameValue: boolean;
        readonly isTooLowCandidateCountWeightHintJoinCandidates: boolean;
        readonly isTooLowCandidateCountWeightHintCancelLeaveCandidates: boolean;
        readonly isTooLowCandidateCountToLeaveCandidates: boolean;
        readonly isTooLowDelegationCountToDelegate: boolean;
        readonly isTooLowCandidateDelegationCountToDelegate: boolean;
        readonly isTooLowDelegationCountToLeaveDelegators: boolean;
        readonly isPendingCandidateRequestsDNE: boolean;
        readonly isPendingCandidateRequestAlreadyExists: boolean;
        readonly isPendingCandidateRequestNotDueYet: boolean;
        readonly isPendingDelegationRequestDNE: boolean;
        readonly isPendingDelegationRequestAlreadyExists: boolean;
        readonly isPendingDelegationRequestNotDueYet: boolean;
        readonly isStakingLiquidityTokenNotListed: boolean;
        readonly isTooLowCurrentStakingLiquidityTokensCount: boolean;
        readonly isStakingLiquidityTokenAlreadyListed: boolean;
        readonly isExceedMaxCollatorCandidates: boolean;
        readonly isExceedMaxTotalDelegatorsPerCandidate: boolean;
        readonly isMathError: boolean;
        readonly type: 'DelegatorDNE' | 'DelegatorDNEinTopNorBottom' | 'DelegatorDNEInDelegatorSet' | 'CandidateDNE' | 'DelegationDNE' | 'DelegatorExists' | 'CandidateExists' | 'CandidateBondBelowMin' | 'InsufficientBalance' | 'DelegationBelowMin' | 'AlreadyOffline' | 'AlreadyActive' | 'DelegatorAlreadyLeaving' | 'DelegatorNotLeaving' | 'DelegatorCannotLeaveYet' | 'CannotDelegateIfLeaving' | 'CandidateAlreadyLeaving' | 'CandidateNotLeaving' | 'CandidateCannotLeaveYet' | 'CannotGoOnlineIfLeaving' | 'ExceedMaxDelegationsPerDelegator' | 'AlreadyDelegatedCandidate' | 'InvalidSchedule' | 'CannotSetBelowMin' | 'NoWritingSameValue' | 'TooLowCandidateCountWeightHintJoinCandidates' | 'TooLowCandidateCountWeightHintCancelLeaveCandidates' | 'TooLowCandidateCountToLeaveCandidates' | 'TooLowDelegationCountToDelegate' | 'TooLowCandidateDelegationCountToDelegate' | 'TooLowDelegationCountToLeaveDelegators' | 'PendingCandidateRequestsDNE' | 'PendingCandidateRequestAlreadyExists' | 'PendingCandidateRequestNotDueYet' | 'PendingDelegationRequestDNE' | 'PendingDelegationRequestAlreadyExists' | 'PendingDelegationRequestNotDueYet' | 'StakingLiquidityTokenNotListed' | 'TooLowCurrentStakingLiquidityTokensCount' | 'StakingLiquidityTokenAlreadyListed' | 'ExceedMaxCollatorCandidates' | 'ExceedMaxTotalDelegatorsPerCandidate' | 'MathError';
    }
    /** @name MangataRococoRuntimeSessionKeys (276) */
    interface MangataRococoRuntimeSessionKeys extends Struct {
        readonly aura: SpConsensusAuraSr25519AppSr25519Public;
    }
    /** @name SpConsensusAuraSr25519AppSr25519Public (277) */
    interface SpConsensusAuraSr25519AppSr25519Public extends SpCoreSr25519Public {
    }
    /** @name SpCoreSr25519Public (278) */
    interface SpCoreSr25519Public extends U8aFixed {
    }
    /** @name SpCoreCryptoKeyTypeId (281) */
    interface SpCoreCryptoKeyTypeId extends U8aFixed {
    }
    /** @name PalletSessionCall (282) */
    interface PalletSessionCall extends Enum {
        readonly isSetKeys: boolean;
        readonly asSetKeys: {
            readonly keys_: MangataRococoRuntimeSessionKeys;
            readonly proof: Bytes;
        } & Struct;
        readonly isPurgeKeys: boolean;
        readonly type: 'SetKeys' | 'PurgeKeys';
    }
    /** @name PalletSessionError (283) */
    interface PalletSessionError extends Enum {
        readonly isInvalidProof: boolean;
        readonly isNoAssociatedValidatorId: boolean;
        readonly isDuplicatedKey: boolean;
        readonly isNoKeys: boolean;
        readonly isNoAccount: boolean;
        readonly type: 'InvalidProof' | 'NoAssociatedValidatorId' | 'DuplicatedKey' | 'NoKeys' | 'NoAccount';
    }
    /** @name PalletMultipurposeLiquidityReserveStatusInfo (287) */
    interface PalletMultipurposeLiquidityReserveStatusInfo extends Struct {
        readonly stakedUnactivatedReserves: u128;
        readonly activatedUnstakedReserves: u128;
        readonly stakedAndActivatedReserves: u128;
        readonly unspentReserves: u128;
        readonly relockAmount: u128;
    }
    /** @name PalletMultipurposeLiquidityRelockStatusInfo (289) */
    interface PalletMultipurposeLiquidityRelockStatusInfo extends Struct {
        readonly amount: u128;
        readonly startingBlock: u32;
        readonly endingBlockAsBalance: u128;
    }
    /** @name PalletMultipurposeLiquidityCall (291) */
    interface PalletMultipurposeLiquidityCall extends Enum {
        readonly isReserveVestingLiquidityTokensByVestingIndex: boolean;
        readonly asReserveVestingLiquidityTokensByVestingIndex: {
            readonly liquidityTokenId: u32;
            readonly liquidityTokenVestingIndex: u32;
            readonly liquidityTokenUnlockSomeAmountOrAll: Option<u128>;
        } & Struct;
        readonly isReserveVestingLiquidityTokens: boolean;
        readonly asReserveVestingLiquidityTokens: {
            readonly liquidityTokenId: u32;
            readonly liquidityTokenAmount: u128;
        } & Struct;
        readonly isUnreserveAndRelockInstance: boolean;
        readonly asUnreserveAndRelockInstance: {
            readonly liquidityTokenId: u32;
            readonly relockInstanceIndex: u32;
        } & Struct;
        readonly type: 'ReserveVestingLiquidityTokensByVestingIndex' | 'ReserveVestingLiquidityTokens' | 'UnreserveAndRelockInstance';
    }
    /** @name PalletMultipurposeLiquidityError (292) */
    interface PalletMultipurposeLiquidityError extends Enum {
        readonly isNotALiquidityToken: boolean;
        readonly isRelockCountLimitExceeded: boolean;
        readonly isRelockInstanceIndexOOB: boolean;
        readonly isNotEnoughUnspentReserves: boolean;
        readonly isNotEnoughTokens: boolean;
        readonly isMathError: boolean;
        readonly type: 'NotALiquidityToken' | 'RelockCountLimitExceeded' | 'RelockInstanceIndexOOB' | 'NotEnoughUnspentReserves' | 'NotEnoughTokens' | 'MathError';
    }
    /** @name CumulusPalletXcmpQueueInboundChannelDetails (294) */
    interface CumulusPalletXcmpQueueInboundChannelDetails extends Struct {
        readonly sender: u32;
        readonly state: CumulusPalletXcmpQueueInboundState;
        readonly messageMetadata: Vec<ITuple<[u32, PolkadotParachainPrimitivesXcmpMessageFormat]>>;
    }
    /** @name CumulusPalletXcmpQueueInboundState (295) */
    interface CumulusPalletXcmpQueueInboundState extends Enum {
        readonly isOk: boolean;
        readonly isSuspended: boolean;
        readonly type: 'Ok' | 'Suspended';
    }
    /** @name PolkadotParachainPrimitivesXcmpMessageFormat (298) */
    interface PolkadotParachainPrimitivesXcmpMessageFormat extends Enum {
        readonly isConcatenatedVersionedXcm: boolean;
        readonly isConcatenatedEncodedBlob: boolean;
        readonly isSignals: boolean;
        readonly type: 'ConcatenatedVersionedXcm' | 'ConcatenatedEncodedBlob' | 'Signals';
    }
    /** @name CumulusPalletXcmpQueueOutboundChannelDetails (301) */
    interface CumulusPalletXcmpQueueOutboundChannelDetails extends Struct {
        readonly recipient: u32;
        readonly state: CumulusPalletXcmpQueueOutboundState;
        readonly signalsExist: bool;
        readonly firstIndex: u16;
        readonly lastIndex: u16;
    }
    /** @name CumulusPalletXcmpQueueOutboundState (302) */
    interface CumulusPalletXcmpQueueOutboundState extends Enum {
        readonly isOk: boolean;
        readonly isSuspended: boolean;
        readonly type: 'Ok' | 'Suspended';
    }
    /** @name CumulusPalletXcmpQueueQueueConfigData (304) */
    interface CumulusPalletXcmpQueueQueueConfigData extends Struct {
        readonly suspendThreshold: u32;
        readonly dropThreshold: u32;
        readonly resumeThreshold: u32;
        readonly thresholdWeight: SpWeightsWeightV2Weight;
        readonly weightRestrictDecay: SpWeightsWeightV2Weight;
        readonly xcmpMaxIndividualWeight: SpWeightsWeightV2Weight;
    }
    /** @name CumulusPalletXcmpQueueCall (306) */
    interface CumulusPalletXcmpQueueCall extends Enum {
        readonly isServiceOverweight: boolean;
        readonly asServiceOverweight: {
            readonly index: u64;
            readonly weightLimit: u64;
        } & Struct;
        readonly isSuspendXcmExecution: boolean;
        readonly isResumeXcmExecution: boolean;
        readonly isUpdateSuspendThreshold: boolean;
        readonly asUpdateSuspendThreshold: {
            readonly new_: u32;
        } & Struct;
        readonly isUpdateDropThreshold: boolean;
        readonly asUpdateDropThreshold: {
            readonly new_: u32;
        } & Struct;
        readonly isUpdateResumeThreshold: boolean;
        readonly asUpdateResumeThreshold: {
            readonly new_: u32;
        } & Struct;
        readonly isUpdateThresholdWeight: boolean;
        readonly asUpdateThresholdWeight: {
            readonly new_: u64;
        } & Struct;
        readonly isUpdateWeightRestrictDecay: boolean;
        readonly asUpdateWeightRestrictDecay: {
            readonly new_: u64;
        } & Struct;
        readonly isUpdateXcmpMaxIndividualWeight: boolean;
        readonly asUpdateXcmpMaxIndividualWeight: {
            readonly new_: u64;
        } & Struct;
        readonly type: 'ServiceOverweight' | 'SuspendXcmExecution' | 'ResumeXcmExecution' | 'UpdateSuspendThreshold' | 'UpdateDropThreshold' | 'UpdateResumeThreshold' | 'UpdateThresholdWeight' | 'UpdateWeightRestrictDecay' | 'UpdateXcmpMaxIndividualWeight';
    }
    /** @name CumulusPalletXcmpQueueError (307) */
    interface CumulusPalletXcmpQueueError extends Enum {
        readonly isFailedToSend: boolean;
        readonly isBadXcmOrigin: boolean;
        readonly isBadXcm: boolean;
        readonly isBadOverweightIndex: boolean;
        readonly isWeightOverLimit: boolean;
        readonly type: 'FailedToSend' | 'BadXcmOrigin' | 'BadXcm' | 'BadOverweightIndex' | 'WeightOverLimit';
    }
    /** @name PalletXcmQueryStatus (308) */
    interface PalletXcmQueryStatus extends Enum {
        readonly isPending: boolean;
        readonly asPending: {
            readonly responder: XcmVersionedMultiLocation;
            readonly maybeNotify: Option<ITuple<[u8, u8]>>;
            readonly timeout: u32;
        } & Struct;
        readonly isVersionNotifier: boolean;
        readonly asVersionNotifier: {
            readonly origin: XcmVersionedMultiLocation;
            readonly isActive: bool;
        } & Struct;
        readonly isReady: boolean;
        readonly asReady: {
            readonly response: XcmVersionedResponse;
            readonly at: u32;
        } & Struct;
        readonly type: 'Pending' | 'VersionNotifier' | 'Ready';
    }
    /** @name XcmVersionedResponse (311) */
    interface XcmVersionedResponse extends Enum {
        readonly isV0: boolean;
        readonly asV0: XcmV0Response;
        readonly isV1: boolean;
        readonly asV1: XcmV1Response;
        readonly isV2: boolean;
        readonly asV2: XcmV2Response;
        readonly type: 'V0' | 'V1' | 'V2';
    }
    /** @name XcmV0Response (312) */
    interface XcmV0Response extends Enum {
        readonly isAssets: boolean;
        readonly asAssets: Vec<XcmV0MultiAsset>;
        readonly type: 'Assets';
    }
    /** @name XcmV1Response (313) */
    interface XcmV1Response extends Enum {
        readonly isAssets: boolean;
        readonly asAssets: XcmV1MultiassetMultiAssets;
        readonly isVersion: boolean;
        readonly asVersion: u32;
        readonly type: 'Assets' | 'Version';
    }
    /** @name PalletXcmVersionMigrationStage (319) */
    interface PalletXcmVersionMigrationStage extends Enum {
        readonly isMigrateSupportedVersion: boolean;
        readonly isMigrateVersionNotifiers: boolean;
        readonly isNotifyCurrentTargets: boolean;
        readonly asNotifyCurrentTargets: Option<Bytes>;
        readonly isMigrateAndNotifyOldTargets: boolean;
        readonly type: 'MigrateSupportedVersion' | 'MigrateVersionNotifiers' | 'NotifyCurrentTargets' | 'MigrateAndNotifyOldTargets';
    }
    /** @name PalletXcmCall (321) */
    interface PalletXcmCall extends Enum {
        readonly isSend: boolean;
        readonly asSend: {
            readonly dest: XcmVersionedMultiLocation;
            readonly message: XcmVersionedXcm;
        } & Struct;
        readonly isTeleportAssets: boolean;
        readonly asTeleportAssets: {
            readonly dest: XcmVersionedMultiLocation;
            readonly beneficiary: XcmVersionedMultiLocation;
            readonly assets: XcmVersionedMultiAssets;
            readonly feeAssetItem: u32;
        } & Struct;
        readonly isReserveTransferAssets: boolean;
        readonly asReserveTransferAssets: {
            readonly dest: XcmVersionedMultiLocation;
            readonly beneficiary: XcmVersionedMultiLocation;
            readonly assets: XcmVersionedMultiAssets;
            readonly feeAssetItem: u32;
        } & Struct;
        readonly isExecute: boolean;
        readonly asExecute: {
            readonly message: XcmVersionedXcm;
            readonly maxWeight: u64;
        } & Struct;
        readonly isForceXcmVersion: boolean;
        readonly asForceXcmVersion: {
            readonly location: XcmV1MultiLocation;
            readonly xcmVersion: u32;
        } & Struct;
        readonly isForceDefaultXcmVersion: boolean;
        readonly asForceDefaultXcmVersion: {
            readonly maybeXcmVersion: Option<u32>;
        } & Struct;
        readonly isForceSubscribeVersionNotify: boolean;
        readonly asForceSubscribeVersionNotify: {
            readonly location: XcmVersionedMultiLocation;
        } & Struct;
        readonly isForceUnsubscribeVersionNotify: boolean;
        readonly asForceUnsubscribeVersionNotify: {
            readonly location: XcmVersionedMultiLocation;
        } & Struct;
        readonly isLimitedReserveTransferAssets: boolean;
        readonly asLimitedReserveTransferAssets: {
            readonly dest: XcmVersionedMultiLocation;
            readonly beneficiary: XcmVersionedMultiLocation;
            readonly assets: XcmVersionedMultiAssets;
            readonly feeAssetItem: u32;
            readonly weightLimit: XcmV2WeightLimit;
        } & Struct;
        readonly isLimitedTeleportAssets: boolean;
        readonly asLimitedTeleportAssets: {
            readonly dest: XcmVersionedMultiLocation;
            readonly beneficiary: XcmVersionedMultiLocation;
            readonly assets: XcmVersionedMultiAssets;
            readonly feeAssetItem: u32;
            readonly weightLimit: XcmV2WeightLimit;
        } & Struct;
        readonly type: 'Send' | 'TeleportAssets' | 'ReserveTransferAssets' | 'Execute' | 'ForceXcmVersion' | 'ForceDefaultXcmVersion' | 'ForceSubscribeVersionNotify' | 'ForceUnsubscribeVersionNotify' | 'LimitedReserveTransferAssets' | 'LimitedTeleportAssets';
    }
    /** @name XcmVersionedXcm (322) */
    interface XcmVersionedXcm extends Enum {
        readonly isV0: boolean;
        readonly asV0: XcmV0Xcm;
        readonly isV1: boolean;
        readonly asV1: XcmV1Xcm;
        readonly isV2: boolean;
        readonly asV2: XcmV2Xcm;
        readonly type: 'V0' | 'V1' | 'V2';
    }
    /** @name XcmV0Xcm (323) */
    interface XcmV0Xcm extends Enum {
        readonly isWithdrawAsset: boolean;
        readonly asWithdrawAsset: {
            readonly assets: Vec<XcmV0MultiAsset>;
            readonly effects: Vec<XcmV0Order>;
        } & Struct;
        readonly isReserveAssetDeposit: boolean;
        readonly asReserveAssetDeposit: {
            readonly assets: Vec<XcmV0MultiAsset>;
            readonly effects: Vec<XcmV0Order>;
        } & Struct;
        readonly isTeleportAsset: boolean;
        readonly asTeleportAsset: {
            readonly assets: Vec<XcmV0MultiAsset>;
            readonly effects: Vec<XcmV0Order>;
        } & Struct;
        readonly isQueryResponse: boolean;
        readonly asQueryResponse: {
            readonly queryId: Compact<u64>;
            readonly response: XcmV0Response;
        } & Struct;
        readonly isTransferAsset: boolean;
        readonly asTransferAsset: {
            readonly assets: Vec<XcmV0MultiAsset>;
            readonly dest: XcmV0MultiLocation;
        } & Struct;
        readonly isTransferReserveAsset: boolean;
        readonly asTransferReserveAsset: {
            readonly assets: Vec<XcmV0MultiAsset>;
            readonly dest: XcmV0MultiLocation;
            readonly effects: Vec<XcmV0Order>;
        } & Struct;
        readonly isTransact: boolean;
        readonly asTransact: {
            readonly originType: XcmV0OriginKind;
            readonly requireWeightAtMost: u64;
            readonly call: XcmDoubleEncoded;
        } & Struct;
        readonly isHrmpNewChannelOpenRequest: boolean;
        readonly asHrmpNewChannelOpenRequest: {
            readonly sender: Compact<u32>;
            readonly maxMessageSize: Compact<u32>;
            readonly maxCapacity: Compact<u32>;
        } & Struct;
        readonly isHrmpChannelAccepted: boolean;
        readonly asHrmpChannelAccepted: {
            readonly recipient: Compact<u32>;
        } & Struct;
        readonly isHrmpChannelClosing: boolean;
        readonly asHrmpChannelClosing: {
            readonly initiator: Compact<u32>;
            readonly sender: Compact<u32>;
            readonly recipient: Compact<u32>;
        } & Struct;
        readonly isRelayedFrom: boolean;
        readonly asRelayedFrom: {
            readonly who: XcmV0MultiLocation;
            readonly message: XcmV0Xcm;
        } & Struct;
        readonly type: 'WithdrawAsset' | 'ReserveAssetDeposit' | 'TeleportAsset' | 'QueryResponse' | 'TransferAsset' | 'TransferReserveAsset' | 'Transact' | 'HrmpNewChannelOpenRequest' | 'HrmpChannelAccepted' | 'HrmpChannelClosing' | 'RelayedFrom';
    }
    /** @name XcmV0Order (325) */
    interface XcmV0Order extends Enum {
        readonly isNull: boolean;
        readonly isDepositAsset: boolean;
        readonly asDepositAsset: {
            readonly assets: Vec<XcmV0MultiAsset>;
            readonly dest: XcmV0MultiLocation;
        } & Struct;
        readonly isDepositReserveAsset: boolean;
        readonly asDepositReserveAsset: {
            readonly assets: Vec<XcmV0MultiAsset>;
            readonly dest: XcmV0MultiLocation;
            readonly effects: Vec<XcmV0Order>;
        } & Struct;
        readonly isExchangeAsset: boolean;
        readonly asExchangeAsset: {
            readonly give: Vec<XcmV0MultiAsset>;
            readonly receive: Vec<XcmV0MultiAsset>;
        } & Struct;
        readonly isInitiateReserveWithdraw: boolean;
        readonly asInitiateReserveWithdraw: {
            readonly assets: Vec<XcmV0MultiAsset>;
            readonly reserve: XcmV0MultiLocation;
            readonly effects: Vec<XcmV0Order>;
        } & Struct;
        readonly isInitiateTeleport: boolean;
        readonly asInitiateTeleport: {
            readonly assets: Vec<XcmV0MultiAsset>;
            readonly dest: XcmV0MultiLocation;
            readonly effects: Vec<XcmV0Order>;
        } & Struct;
        readonly isQueryHolding: boolean;
        readonly asQueryHolding: {
            readonly queryId: Compact<u64>;
            readonly dest: XcmV0MultiLocation;
            readonly assets: Vec<XcmV0MultiAsset>;
        } & Struct;
        readonly isBuyExecution: boolean;
        readonly asBuyExecution: {
            readonly fees: XcmV0MultiAsset;
            readonly weight: u64;
            readonly debt: u64;
            readonly haltOnError: bool;
            readonly xcm: Vec<XcmV0Xcm>;
        } & Struct;
        readonly type: 'Null' | 'DepositAsset' | 'DepositReserveAsset' | 'ExchangeAsset' | 'InitiateReserveWithdraw' | 'InitiateTeleport' | 'QueryHolding' | 'BuyExecution';
    }
    /** @name XcmV1Xcm (327) */
    interface XcmV1Xcm extends Enum {
        readonly isWithdrawAsset: boolean;
        readonly asWithdrawAsset: {
            readonly assets: XcmV1MultiassetMultiAssets;
            readonly effects: Vec<XcmV1Order>;
        } & Struct;
        readonly isReserveAssetDeposited: boolean;
        readonly asReserveAssetDeposited: {
            readonly assets: XcmV1MultiassetMultiAssets;
            readonly effects: Vec<XcmV1Order>;
        } & Struct;
        readonly isReceiveTeleportedAsset: boolean;
        readonly asReceiveTeleportedAsset: {
            readonly assets: XcmV1MultiassetMultiAssets;
            readonly effects: Vec<XcmV1Order>;
        } & Struct;
        readonly isQueryResponse: boolean;
        readonly asQueryResponse: {
            readonly queryId: Compact<u64>;
            readonly response: XcmV1Response;
        } & Struct;
        readonly isTransferAsset: boolean;
        readonly asTransferAsset: {
            readonly assets: XcmV1MultiassetMultiAssets;
            readonly beneficiary: XcmV1MultiLocation;
        } & Struct;
        readonly isTransferReserveAsset: boolean;
        readonly asTransferReserveAsset: {
            readonly assets: XcmV1MultiassetMultiAssets;
            readonly dest: XcmV1MultiLocation;
            readonly effects: Vec<XcmV1Order>;
        } & Struct;
        readonly isTransact: boolean;
        readonly asTransact: {
            readonly originType: XcmV0OriginKind;
            readonly requireWeightAtMost: u64;
            readonly call: XcmDoubleEncoded;
        } & Struct;
        readonly isHrmpNewChannelOpenRequest: boolean;
        readonly asHrmpNewChannelOpenRequest: {
            readonly sender: Compact<u32>;
            readonly maxMessageSize: Compact<u32>;
            readonly maxCapacity: Compact<u32>;
        } & Struct;
        readonly isHrmpChannelAccepted: boolean;
        readonly asHrmpChannelAccepted: {
            readonly recipient: Compact<u32>;
        } & Struct;
        readonly isHrmpChannelClosing: boolean;
        readonly asHrmpChannelClosing: {
            readonly initiator: Compact<u32>;
            readonly sender: Compact<u32>;
            readonly recipient: Compact<u32>;
        } & Struct;
        readonly isRelayedFrom: boolean;
        readonly asRelayedFrom: {
            readonly who: XcmV1MultilocationJunctions;
            readonly message: XcmV1Xcm;
        } & Struct;
        readonly isSubscribeVersion: boolean;
        readonly asSubscribeVersion: {
            readonly queryId: Compact<u64>;
            readonly maxResponseWeight: Compact<u64>;
        } & Struct;
        readonly isUnsubscribeVersion: boolean;
        readonly type: 'WithdrawAsset' | 'ReserveAssetDeposited' | 'ReceiveTeleportedAsset' | 'QueryResponse' | 'TransferAsset' | 'TransferReserveAsset' | 'Transact' | 'HrmpNewChannelOpenRequest' | 'HrmpChannelAccepted' | 'HrmpChannelClosing' | 'RelayedFrom' | 'SubscribeVersion' | 'UnsubscribeVersion';
    }
    /** @name XcmV1Order (329) */
    interface XcmV1Order extends Enum {
        readonly isNoop: boolean;
        readonly isDepositAsset: boolean;
        readonly asDepositAsset: {
            readonly assets: XcmV1MultiassetMultiAssetFilter;
            readonly maxAssets: u32;
            readonly beneficiary: XcmV1MultiLocation;
        } & Struct;
        readonly isDepositReserveAsset: boolean;
        readonly asDepositReserveAsset: {
            readonly assets: XcmV1MultiassetMultiAssetFilter;
            readonly maxAssets: u32;
            readonly dest: XcmV1MultiLocation;
            readonly effects: Vec<XcmV1Order>;
        } & Struct;
        readonly isExchangeAsset: boolean;
        readonly asExchangeAsset: {
            readonly give: XcmV1MultiassetMultiAssetFilter;
            readonly receive: XcmV1MultiassetMultiAssets;
        } & Struct;
        readonly isInitiateReserveWithdraw: boolean;
        readonly asInitiateReserveWithdraw: {
            readonly assets: XcmV1MultiassetMultiAssetFilter;
            readonly reserve: XcmV1MultiLocation;
            readonly effects: Vec<XcmV1Order>;
        } & Struct;
        readonly isInitiateTeleport: boolean;
        readonly asInitiateTeleport: {
            readonly assets: XcmV1MultiassetMultiAssetFilter;
            readonly dest: XcmV1MultiLocation;
            readonly effects: Vec<XcmV1Order>;
        } & Struct;
        readonly isQueryHolding: boolean;
        readonly asQueryHolding: {
            readonly queryId: Compact<u64>;
            readonly dest: XcmV1MultiLocation;
            readonly assets: XcmV1MultiassetMultiAssetFilter;
        } & Struct;
        readonly isBuyExecution: boolean;
        readonly asBuyExecution: {
            readonly fees: XcmV1MultiAsset;
            readonly weight: u64;
            readonly debt: u64;
            readonly haltOnError: bool;
            readonly instructions: Vec<XcmV1Xcm>;
        } & Struct;
        readonly type: 'Noop' | 'DepositAsset' | 'DepositReserveAsset' | 'ExchangeAsset' | 'InitiateReserveWithdraw' | 'InitiateTeleport' | 'QueryHolding' | 'BuyExecution';
    }
    /** @name PalletXcmError (344) */
    interface PalletXcmError extends Enum {
        readonly isUnreachable: boolean;
        readonly isSendFailure: boolean;
        readonly isFiltered: boolean;
        readonly isUnweighableMessage: boolean;
        readonly isDestinationNotInvertible: boolean;
        readonly isEmpty: boolean;
        readonly isCannotReanchor: boolean;
        readonly isTooManyAssets: boolean;
        readonly isInvalidOrigin: boolean;
        readonly isBadVersion: boolean;
        readonly isBadLocation: boolean;
        readonly isNoSubscription: boolean;
        readonly isAlreadySubscribed: boolean;
        readonly type: 'Unreachable' | 'SendFailure' | 'Filtered' | 'UnweighableMessage' | 'DestinationNotInvertible' | 'Empty' | 'CannotReanchor' | 'TooManyAssets' | 'InvalidOrigin' | 'BadVersion' | 'BadLocation' | 'NoSubscription' | 'AlreadySubscribed';
    }
    /** @name CumulusPalletXcmError (345) */
    type CumulusPalletXcmError = Null;
    /** @name CumulusPalletDmpQueueConfigData (346) */
    interface CumulusPalletDmpQueueConfigData extends Struct {
        readonly maxIndividual: SpWeightsWeightV2Weight;
    }
    /** @name CumulusPalletDmpQueuePageIndexData (347) */
    interface CumulusPalletDmpQueuePageIndexData extends Struct {
        readonly beginUsed: u32;
        readonly endUsed: u32;
        readonly overweightCount: u64;
    }
    /** @name CumulusPalletDmpQueueCall (350) */
    interface CumulusPalletDmpQueueCall extends Enum {
        readonly isServiceOverweight: boolean;
        readonly asServiceOverweight: {
            readonly index: u64;
            readonly weightLimit: u64;
        } & Struct;
        readonly type: 'ServiceOverweight';
    }
    /** @name CumulusPalletDmpQueueError (351) */
    interface CumulusPalletDmpQueueError extends Enum {
        readonly isUnknown: boolean;
        readonly isOverLimit: boolean;
        readonly type: 'Unknown' | 'OverLimit';
    }
    /** @name OrmlXtokensModuleCall (352) */
    interface OrmlXtokensModuleCall extends Enum {
        readonly isTransfer: boolean;
        readonly asTransfer: {
            readonly currencyId: u32;
            readonly amount: u128;
            readonly dest: XcmVersionedMultiLocation;
            readonly destWeightLimit: XcmV2WeightLimit;
        } & Struct;
        readonly isTransferMultiasset: boolean;
        readonly asTransferMultiasset: {
            readonly asset: XcmVersionedMultiAsset;
            readonly dest: XcmVersionedMultiLocation;
            readonly destWeightLimit: XcmV2WeightLimit;
        } & Struct;
        readonly isTransferWithFee: boolean;
        readonly asTransferWithFee: {
            readonly currencyId: u32;
            readonly amount: u128;
            readonly fee: u128;
            readonly dest: XcmVersionedMultiLocation;
            readonly destWeightLimit: XcmV2WeightLimit;
        } & Struct;
        readonly isTransferMultiassetWithFee: boolean;
        readonly asTransferMultiassetWithFee: {
            readonly asset: XcmVersionedMultiAsset;
            readonly fee: XcmVersionedMultiAsset;
            readonly dest: XcmVersionedMultiLocation;
            readonly destWeightLimit: XcmV2WeightLimit;
        } & Struct;
        readonly isTransferMulticurrencies: boolean;
        readonly asTransferMulticurrencies: {
            readonly currencies: Vec<ITuple<[u32, u128]>>;
            readonly feeItem: u32;
            readonly dest: XcmVersionedMultiLocation;
            readonly destWeightLimit: XcmV2WeightLimit;
        } & Struct;
        readonly isTransferMultiassets: boolean;
        readonly asTransferMultiassets: {
            readonly assets: XcmVersionedMultiAssets;
            readonly feeItem: u32;
            readonly dest: XcmVersionedMultiLocation;
            readonly destWeightLimit: XcmV2WeightLimit;
        } & Struct;
        readonly type: 'Transfer' | 'TransferMultiasset' | 'TransferWithFee' | 'TransferMultiassetWithFee' | 'TransferMulticurrencies' | 'TransferMultiassets';
    }
    /** @name XcmVersionedMultiAsset (353) */
    interface XcmVersionedMultiAsset extends Enum {
        readonly isV0: boolean;
        readonly asV0: XcmV0MultiAsset;
        readonly isV1: boolean;
        readonly asV1: XcmV1MultiAsset;
        readonly type: 'V0' | 'V1';
    }
    /** @name OrmlXtokensModuleError (354) */
    interface OrmlXtokensModuleError extends Enum {
        readonly isAssetHasNoReserve: boolean;
        readonly isNotCrossChainTransfer: boolean;
        readonly isInvalidDest: boolean;
        readonly isNotCrossChainTransferableCurrency: boolean;
        readonly isUnweighableMessage: boolean;
        readonly isXcmExecutionFailed: boolean;
        readonly isCannotReanchor: boolean;
        readonly isInvalidAncestry: boolean;
        readonly isInvalidAsset: boolean;
        readonly isDestinationNotInvertible: boolean;
        readonly isBadVersion: boolean;
        readonly isDistinctReserveForAssetAndFee: boolean;
        readonly isZeroFee: boolean;
        readonly isZeroAmount: boolean;
        readonly isTooManyAssetsBeingSent: boolean;
        readonly isAssetIndexNonExistent: boolean;
        readonly isFeeNotEnough: boolean;
        readonly isNotSupportedMultiLocation: boolean;
        readonly isMinXcmFeeNotDefined: boolean;
        readonly type: 'AssetHasNoReserve' | 'NotCrossChainTransfer' | 'InvalidDest' | 'NotCrossChainTransferableCurrency' | 'UnweighableMessage' | 'XcmExecutionFailed' | 'CannotReanchor' | 'InvalidAncestry' | 'InvalidAsset' | 'DestinationNotInvertible' | 'BadVersion' | 'DistinctReserveForAssetAndFee' | 'ZeroFee' | 'ZeroAmount' | 'TooManyAssetsBeingSent' | 'AssetIndexNonExistent' | 'FeeNotEnough' | 'NotSupportedMultiLocation' | 'MinXcmFeeNotDefined';
    }
    /** @name OrmlUnknownTokensModuleError (357) */
    interface OrmlUnknownTokensModuleError extends Enum {
        readonly isBalanceTooLow: boolean;
        readonly isBalanceOverflow: boolean;
        readonly isUnhandledAsset: boolean;
        readonly type: 'BalanceTooLow' | 'BalanceOverflow' | 'UnhandledAsset';
    }
    /** @name OrmlXcmModuleCall (358) */
    interface OrmlXcmModuleCall extends Enum {
        readonly isSendAsSovereign: boolean;
        readonly asSendAsSovereign: {
            readonly dest: XcmVersionedMultiLocation;
            readonly message: XcmVersionedXcm;
        } & Struct;
        readonly type: 'SendAsSovereign';
    }
    /** @name OrmlXcmModuleError (359) */
    interface OrmlXcmModuleError extends Enum {
        readonly isUnreachable: boolean;
        readonly isSendFailure: boolean;
        readonly isBadVersion: boolean;
        readonly type: 'Unreachable' | 'SendFailure' | 'BadVersion';
    }
    /** @name OrmlAssetRegistryModuleCall (360) */
    interface OrmlAssetRegistryModuleCall extends Enum {
        readonly isRegisterAsset: boolean;
        readonly asRegisterAsset: {
            readonly metadata: OrmlTraitsAssetRegistryAssetMetadata;
            readonly assetId: Option<u32>;
        } & Struct;
        readonly isUpdateAsset: boolean;
        readonly asUpdateAsset: {
            readonly assetId: u32;
            readonly decimals: Option<u32>;
            readonly name: Option<Bytes>;
            readonly symbol: Option<Bytes>;
            readonly existentialDeposit: Option<u128>;
            readonly location: Option<Option<XcmVersionedMultiLocation>>;
            readonly additional: Option<MangataTypesAssetsCustomMetadata>;
        } & Struct;
        readonly type: 'RegisterAsset' | 'UpdateAsset';
    }
    /** @name OrmlAssetRegistryModuleError (363) */
    interface OrmlAssetRegistryModuleError extends Enum {
        readonly isAssetNotFound: boolean;
        readonly isBadVersion: boolean;
        readonly isInvalidAssetId: boolean;
        readonly isConflictingLocation: boolean;
        readonly isConflictingAssetId: boolean;
        readonly type: 'AssetNotFound' | 'BadVersion' | 'InvalidAssetId' | 'ConflictingLocation' | 'ConflictingAssetId';
    }
    /** @name PalletTreasuryProposal (364) */
    interface PalletTreasuryProposal extends Struct {
        readonly proposer: AccountId32;
        readonly value: u128;
        readonly beneficiary: AccountId32;
        readonly bond: u128;
    }
    /** @name PalletTreasuryCall (366) */
    interface PalletTreasuryCall extends Enum {
        readonly isProposeSpend: boolean;
        readonly asProposeSpend: {
            readonly value: Compact<u128>;
            readonly beneficiary: MultiAddress;
        } & Struct;
        readonly isRejectProposal: boolean;
        readonly asRejectProposal: {
            readonly proposalId: Compact<u32>;
        } & Struct;
        readonly isApproveProposal: boolean;
        readonly asApproveProposal: {
            readonly proposalId: Compact<u32>;
        } & Struct;
        readonly isSpend: boolean;
        readonly asSpend: {
            readonly amount: Compact<u128>;
            readonly beneficiary: MultiAddress;
        } & Struct;
        readonly isRemoveApproval: boolean;
        readonly asRemoveApproval: {
            readonly proposalId: Compact<u32>;
        } & Struct;
        readonly type: 'ProposeSpend' | 'RejectProposal' | 'ApproveProposal' | 'Spend' | 'RemoveApproval';
    }
    /** @name FrameSupportPalletId (367) */
    interface FrameSupportPalletId extends U8aFixed {
    }
    /** @name PalletTreasuryError (368) */
    interface PalletTreasuryError extends Enum {
        readonly isInsufficientProposersBalance: boolean;
        readonly isInvalidIndex: boolean;
        readonly isTooManyApprovals: boolean;
        readonly isInsufficientPermission: boolean;
        readonly isProposalNotApproved: boolean;
        readonly type: 'InsufficientProposersBalance' | 'InvalidIndex' | 'TooManyApprovals' | 'InsufficientPermission' | 'ProposalNotApproved';
    }
    /** @name PalletSudoMangataCall (369) */
    interface PalletSudoMangataCall extends Enum {
        readonly isSudo: boolean;
        readonly asSudo: {
            readonly call: Call;
        } & Struct;
        readonly isSudoUncheckedWeight: boolean;
        readonly asSudoUncheckedWeight: {
            readonly call: Call;
            readonly weight: SpWeightsWeightV2Weight;
        } & Struct;
        readonly isSetKey: boolean;
        readonly asSetKey: {
            readonly new_: MultiAddress;
        } & Struct;
        readonly isSudoAs: boolean;
        readonly asSudoAs: {
            readonly who: MultiAddress;
            readonly call: Call;
        } & Struct;
        readonly type: 'Sudo' | 'SudoUncheckedWeight' | 'SetKey' | 'SudoAs';
    }
    /** @name PalletSudoOriginCall (371) */
    interface PalletSudoOriginCall extends Enum {
        readonly isSudo: boolean;
        readonly asSudo: {
            readonly call: Call;
        } & Struct;
        readonly isSudoUncheckedWeight: boolean;
        readonly asSudoUncheckedWeight: {
            readonly call: Call;
            readonly weight: SpWeightsWeightV2Weight;
        } & Struct;
        readonly isSudoAs: boolean;
        readonly asSudoAs: {
            readonly who: MultiAddress;
            readonly call: Call;
        } & Struct;
        readonly type: 'Sudo' | 'SudoUncheckedWeight' | 'SudoAs';
    }
    /** @name PalletCollectiveMangataCall (372) */
    interface PalletCollectiveMangataCall extends Enum {
        readonly isSetMembers: boolean;
        readonly asSetMembers: {
            readonly newMembers: Vec<AccountId32>;
            readonly prime: Option<AccountId32>;
            readonly oldCount: u32;
        } & Struct;
        readonly isExecute: boolean;
        readonly asExecute: {
            readonly proposal: Call;
            readonly lengthBound: Compact<u32>;
        } & Struct;
        readonly isPropose: boolean;
        readonly asPropose: {
            readonly threshold: Compact<u32>;
            readonly proposal: Call;
            readonly lengthBound: Compact<u32>;
        } & Struct;
        readonly isVote: boolean;
        readonly asVote: {
            readonly proposal: H256;
            readonly index: Compact<u32>;
            readonly approve: bool;
        } & Struct;
        readonly isClose: boolean;
        readonly asClose: {
            readonly proposalHash: H256;
            readonly index: Compact<u32>;
            readonly proposalWeightBound: SpWeightsWeightV2Weight;
            readonly lengthBound: Compact<u32>;
        } & Struct;
        readonly isDisapproveProposal: boolean;
        readonly asDisapproveProposal: {
            readonly proposalHash: H256;
        } & Struct;
        readonly type: 'SetMembers' | 'Execute' | 'Propose' | 'Vote' | 'Close' | 'DisapproveProposal';
    }
    /** @name PalletBootstrapCall (373) */
    interface PalletBootstrapCall extends Enum {
        readonly isProvision: boolean;
        readonly asProvision: {
            readonly tokenId: u32;
            readonly amount: u128;
        } & Struct;
        readonly isWhitelistAccounts: boolean;
        readonly asWhitelistAccounts: {
            readonly accounts: Vec<AccountId32>;
        } & Struct;
        readonly isScheduleBootstrap: boolean;
        readonly asScheduleBootstrap: {
            readonly firstTokenId: u32;
            readonly secondTokenId: u32;
            readonly idoStart: u32;
            readonly whitelistPhaseLength: Option<u32>;
            readonly publicPhaseLenght: u32;
            readonly maxFirstToSecondRatio: Option<ITuple<[u128, u128]>>;
            readonly promoteBootstrapPool: bool;
        } & Struct;
        readonly isCancelBootstrap: boolean;
        readonly isUpdatePromoteBootstrapPool: boolean;
        readonly asUpdatePromoteBootstrapPool: {
            readonly promoteBootstrapPool: bool;
        } & Struct;
        readonly isClaimLiquidityTokens: boolean;
        readonly isClaimAndActivateLiquidityTokens: boolean;
        readonly isFinalize: boolean;
        readonly asFinalize: {
            readonly limit: u32;
        } & Struct;
        readonly isClaimLiquidityTokensForAccount: boolean;
        readonly asClaimLiquidityTokensForAccount: {
            readonly account: AccountId32;
            readonly activateRewards: bool;
        } & Struct;
        readonly type: 'Provision' | 'WhitelistAccounts' | 'ScheduleBootstrap' | 'CancelBootstrap' | 'UpdatePromoteBootstrapPool' | 'ClaimLiquidityTokens' | 'ClaimAndActivateLiquidityTokens' | 'Finalize' | 'ClaimLiquidityTokensForAccount';
    }
    /** @name PalletUtilityCall (374) */
    interface PalletUtilityCall extends Enum {
        readonly isBatch: boolean;
        readonly asBatch: {
            readonly calls: Vec<Call>;
        } & Struct;
        readonly isAsDerivative: boolean;
        readonly asAsDerivative: {
            readonly index: u16;
            readonly call: Call;
        } & Struct;
        readonly isBatchAll: boolean;
        readonly asBatchAll: {
            readonly calls: Vec<Call>;
        } & Struct;
        readonly isDispatchAs: boolean;
        readonly asDispatchAs: {
            readonly asOrigin: MangataRococoRuntimeOriginCaller;
            readonly call: Call;
        } & Struct;
        readonly isForceBatch: boolean;
        readonly asForceBatch: {
            readonly calls: Vec<Call>;
        } & Struct;
        readonly type: 'Batch' | 'AsDerivative' | 'BatchAll' | 'DispatchAs' | 'ForceBatch';
    }
    /** @name MangataRococoRuntimeOriginCaller (376) */
    interface MangataRococoRuntimeOriginCaller extends Enum {
        readonly isSystem: boolean;
        readonly asSystem: FrameSupportDispatchRawOrigin;
        readonly isVoid: boolean;
        readonly isPolkadotXcm: boolean;
        readonly asPolkadotXcm: PalletXcmOrigin;
        readonly isCumulusXcm: boolean;
        readonly asCumulusXcm: CumulusPalletXcmOrigin;
        readonly isCouncil: boolean;
        readonly asCouncil: PalletCollectiveMangataRawOrigin;
        readonly type: 'System' | 'Void' | 'PolkadotXcm' | 'CumulusXcm' | 'Council';
    }
    /** @name FrameSupportDispatchRawOrigin (377) */
    interface FrameSupportDispatchRawOrigin extends Enum {
        readonly isRoot: boolean;
        readonly isSigned: boolean;
        readonly asSigned: AccountId32;
        readonly isNone: boolean;
        readonly type: 'Root' | 'Signed' | 'None';
    }
    /** @name PalletXcmOrigin (378) */
    interface PalletXcmOrigin extends Enum {
        readonly isXcm: boolean;
        readonly asXcm: XcmV1MultiLocation;
        readonly isResponse: boolean;
        readonly asResponse: XcmV1MultiLocation;
        readonly type: 'Xcm' | 'Response';
    }
    /** @name CumulusPalletXcmOrigin (379) */
    interface CumulusPalletXcmOrigin extends Enum {
        readonly isRelay: boolean;
        readonly isSiblingParachain: boolean;
        readonly asSiblingParachain: u32;
        readonly type: 'Relay' | 'SiblingParachain';
    }
    /** @name PalletCollectiveMangataRawOrigin (380) */
    interface PalletCollectiveMangataRawOrigin extends Enum {
        readonly isMembers: boolean;
        readonly asMembers: ITuple<[u32, u32]>;
        readonly isMember: boolean;
        readonly asMember: AccountId32;
        readonly isPhantom: boolean;
        readonly type: 'Members' | 'Member' | 'Phantom';
    }
    /** @name SpCoreVoid (381) */
    type SpCoreVoid = Null;
    /** @name PalletProxyCall (382) */
    interface PalletProxyCall extends Enum {
        readonly isProxy: boolean;
        readonly asProxy: {
            readonly real: MultiAddress;
            readonly forceProxyType: Option<MangataRococoRuntimeProxyType>;
            readonly call: Call;
        } & Struct;
        readonly isAddProxy: boolean;
        readonly asAddProxy: {
            readonly delegate: MultiAddress;
            readonly proxyType: MangataRococoRuntimeProxyType;
            readonly delay: u32;
        } & Struct;
        readonly isRemoveProxy: boolean;
        readonly asRemoveProxy: {
            readonly delegate: MultiAddress;
            readonly proxyType: MangataRococoRuntimeProxyType;
            readonly delay: u32;
        } & Struct;
        readonly isRemoveProxies: boolean;
        readonly isCreatePure: boolean;
        readonly asCreatePure: {
            readonly proxyType: MangataRococoRuntimeProxyType;
            readonly delay: u32;
            readonly index: u16;
        } & Struct;
        readonly isKillPure: boolean;
        readonly asKillPure: {
            readonly spawner: MultiAddress;
            readonly proxyType: MangataRococoRuntimeProxyType;
            readonly index: u16;
            readonly height: Compact<u32>;
            readonly extIndex: Compact<u32>;
        } & Struct;
        readonly isAnnounce: boolean;
        readonly asAnnounce: {
            readonly real: MultiAddress;
            readonly callHash: H256;
        } & Struct;
        readonly isRemoveAnnouncement: boolean;
        readonly asRemoveAnnouncement: {
            readonly real: MultiAddress;
            readonly callHash: H256;
        } & Struct;
        readonly isRejectAnnouncement: boolean;
        readonly asRejectAnnouncement: {
            readonly delegate: MultiAddress;
            readonly callHash: H256;
        } & Struct;
        readonly isProxyAnnounced: boolean;
        readonly asProxyAnnounced: {
            readonly delegate: MultiAddress;
            readonly real: MultiAddress;
            readonly forceProxyType: Option<MangataRococoRuntimeProxyType>;
            readonly call: Call;
        } & Struct;
        readonly type: 'Proxy' | 'AddProxy' | 'RemoveProxy' | 'RemoveProxies' | 'CreatePure' | 'KillPure' | 'Announce' | 'RemoveAnnouncement' | 'RejectAnnouncement' | 'ProxyAnnounced';
    }
    /** @name PalletSudoMangataError (384) */
    interface PalletSudoMangataError extends Enum {
        readonly isRequireSudo: boolean;
        readonly type: 'RequireSudo';
    }
    /** @name PalletSudoOriginError (385) */
    type PalletSudoOriginError = Null;
    /** @name PalletCollectiveMangataVotes (387) */
    interface PalletCollectiveMangataVotes extends Struct {
        readonly index: u32;
        readonly threshold: u32;
        readonly ayes: Vec<AccountId32>;
        readonly nays: Vec<AccountId32>;
        readonly end: u32;
    }
    /** @name PalletCollectiveMangataError (388) */
    interface PalletCollectiveMangataError extends Enum {
        readonly isNotMember: boolean;
        readonly isDuplicateProposal: boolean;
        readonly isProposalMissing: boolean;
        readonly isWrongIndex: boolean;
        readonly isDuplicateVote: boolean;
        readonly isAlreadyInitialized: boolean;
        readonly isTooEarly: boolean;
        readonly isTooEarlyToClose: boolean;
        readonly isTooManyProposals: boolean;
        readonly isWrongProposalWeight: boolean;
        readonly isWrongProposalLength: boolean;
        readonly type: 'NotMember' | 'DuplicateProposal' | 'ProposalMissing' | 'WrongIndex' | 'DuplicateVote' | 'AlreadyInitialized' | 'TooEarly' | 'TooEarlyToClose' | 'TooManyProposals' | 'WrongProposalWeight' | 'WrongProposalLength';
    }
    /** @name PalletBootstrapBootstrapPhase (390) */
    interface PalletBootstrapBootstrapPhase extends Enum {
        readonly isBeforeStart: boolean;
        readonly isWhitelist: boolean;
        readonly isPublic: boolean;
        readonly isFinished: boolean;
        readonly type: 'BeforeStart' | 'Whitelist' | 'Public' | 'Finished';
    }
    /** @name PalletBootstrapError (393) */
    interface PalletBootstrapError extends Enum {
        readonly isUnsupportedTokenId: boolean;
        readonly isNotEnoughAssets: boolean;
        readonly isNotEnoughVestedAssets: boolean;
        readonly isMathOverflow: boolean;
        readonly isUnauthorized: boolean;
        readonly isBootstrapStartInThePast: boolean;
        readonly isPhaseLengthCannotBeZero: boolean;
        readonly isAlreadyStarted: boolean;
        readonly isValuationRatio: boolean;
        readonly isFirstProvisionInSecondTokenId: boolean;
        readonly isPoolAlreadyExists: boolean;
        readonly isNotFinishedYet: boolean;
        readonly isNothingToClaim: boolean;
        readonly isWrongRatio: boolean;
        readonly isBootstrapNotReadyToBeFinished: boolean;
        readonly isSameToken: boolean;
        readonly isTokenIdDoesNotExists: boolean;
        readonly isTokensActivationFailed: boolean;
        readonly isBootstrapNotSchduled: boolean;
        readonly isBootstrapFinished: boolean;
        readonly isTooLateToUpdateBootstrap: boolean;
        readonly type: 'UnsupportedTokenId' | 'NotEnoughAssets' | 'NotEnoughVestedAssets' | 'MathOverflow' | 'Unauthorized' | 'BootstrapStartInThePast' | 'PhaseLengthCannotBeZero' | 'AlreadyStarted' | 'ValuationRatio' | 'FirstProvisionInSecondTokenId' | 'PoolAlreadyExists' | 'NotFinishedYet' | 'NothingToClaim' | 'WrongRatio' | 'BootstrapNotReadyToBeFinished' | 'SameToken' | 'TokenIdDoesNotExists' | 'TokensActivationFailed' | 'BootstrapNotSchduled' | 'BootstrapFinished' | 'TooLateToUpdateBootstrap';
    }
    /** @name PalletUtilityError (394) */
    interface PalletUtilityError extends Enum {
        readonly isTooManyCalls: boolean;
        readonly type: 'TooManyCalls';
    }
    /** @name PalletProxyProxyDefinition (397) */
    interface PalletProxyProxyDefinition extends Struct {
        readonly delegate: AccountId32;
        readonly proxyType: MangataRococoRuntimeProxyType;
        readonly delay: u32;
    }
    /** @name PalletProxyAnnouncement (401) */
    interface PalletProxyAnnouncement extends Struct {
        readonly real: AccountId32;
        readonly callHash: H256;
        readonly height: u32;
    }
    /** @name PalletProxyError (403) */
    interface PalletProxyError extends Enum {
        readonly isTooMany: boolean;
        readonly isNotFound: boolean;
        readonly isNotProxy: boolean;
        readonly isUnproxyable: boolean;
        readonly isDuplicate: boolean;
        readonly isNoPermission: boolean;
        readonly isUnannounced: boolean;
        readonly isNoSelfProxy: boolean;
        readonly type: 'TooMany' | 'NotFound' | 'NotProxy' | 'Unproxyable' | 'Duplicate' | 'NoPermission' | 'Unannounced' | 'NoSelfProxy';
    }
    /** @name FrameSystemExtensionsCheckSpecVersion (406) */
    type FrameSystemExtensionsCheckSpecVersion = Null;
    /** @name FrameSystemExtensionsCheckTxVersion (407) */
    type FrameSystemExtensionsCheckTxVersion = Null;
    /** @name FrameSystemExtensionsCheckGenesis (408) */
    type FrameSystemExtensionsCheckGenesis = Null;
    /** @name FrameSystemExtensionsCheckNonce (411) */
    interface FrameSystemExtensionsCheckNonce extends Compact<u32> {
    }
    /** @name FrameSystemExtensionsCheckWeight (412) */
    type FrameSystemExtensionsCheckWeight = Null;
    /** @name PalletTransactionPaymentChargeTransactionPayment (413) */
    interface PalletTransactionPaymentChargeTransactionPayment extends Compact<u128> {
    }
    /** @name MangataRococoRuntimeRuntime (414) */
    type MangataRococoRuntimeRuntime = Null;
}
