{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/connector/types.ts"],"names":[],"mappings":"AAmIA,MAAM,OAAO,qBAAsB,SAAQ,KAAK;IAC9C;QACE,KAAK,EAAE,CAAA;QACP,IAAI,CAAC,IAAI,GAAG,uBAAuB,CAAA;IACrC,CAAC;CACF;AAED,MAAM,OAAO,UAAW,SAAQ,KAAK;IACnC,YAAY,OAAe;QACzB,KAAK,CAAC,OAAO,CAAC,CAAA;QACd,IAAI,CAAC,IAAI,GAAG,YAAY,CAAA;IAC1B,CAAC;CACF;AAED,MAAM,OAAO,oBAAqB,SAAQ,KAAK;IAC7C;QACE,KAAK,EAAE,CAAA;QACP,IAAI,CAAC,IAAI,GAAG,sBAAsB,CAAA;IACpC,CAAC;CACF","sourcesContent":["import { WellKnownChain } from \"../WellKnownChain.js\"\n\n/**\n * Active connection to a blockchain.\n */\nexport interface Chain {\n  /**\n   * Enqueues a JSON-RPC request that the client will process as soon as possible.\n   *\n   * The response will be sent back using the callback passed when adding the chain.\n   *\n   * See <https://www.jsonrpc.org/specification> for a specification of the JSON-RPC format. Only\n   * version 2 is supported.\n   * Be aware that some requests will cause notifications to be sent back using the same callback\n   * as the responses.\n   *\n   * No response is generated if the request isn't a valid JSON-RPC request or if the request is\n   * unreasonably large (8 MiB at the time of writing of this comment). The request is then\n   * silently discarded.\n   * If, however, the request is a valid JSON-RPC request but that concerns an unknown method, a\n   * error response is properly generated.\n   *\n   * Two JSON-RPC APIs are supported:\n   *\n   * - The \"legacy\" one, documented here: <https://polkadot.js.org/docs/substrate/rpc>\n   * - The more recent one: <https://github.com/paritytech/json-rpc-interface-spec>\n   *\n   * @param rpc JSON-encoded RPC request.\n   *\n   * @throws {AlreadyDestroyedError} If the chain has been removed.\n   * @throws {JsonRpcDisabledError} If no JSON-RPC callback was passed in the options of the chain.\n   * @throws {CrashError} If the background client has crashed.\n   */\n  sendJsonRpc(rpc: string): void\n\n  /**\n   * Disconnects from the blockchain.\n   *\n   * The JSON-RPC callback will no longer be called.\n   *\n   * Trying to use the chain again will lead to an exception being thrown.\n   *\n   * If this chain is a relay chain, then all parachains that use it will continue to work. Smoldot\n   * automatically keeps alive all relay chains that have an active parachains. There is no need\n   * to track parachains and relaychains, or to destroy them in the correct order, as this is\n   * handled automatically.\n   *\n   * @throws {AlreadyDestroyedError} If the chain has already been removed.\n   * @throws {CrashError} If the background client has crashed.\n   */\n  remove(): void\n}\n\nexport type JsonRpcCallback = (response: string) => void\n\nexport type AddChain = (\n  chainSpec: string,\n  jsonRpcCallback?: JsonRpcCallback,\n) => Promise<Chain>\n\nexport type AddWellKnownChain = (\n  id: WellKnownChain,\n  jsonRpcCallback?: JsonRpcCallback,\n) => Promise<Chain>\n\n/**\n * Client that allows connecting to chains.\n *\n * Use {ScClient.addChain} or {ScClient.addWellKnownChain} to connect to a\n * chain.\n *\n * If you want to connect to a parachain, you **must** have connected to its corresponding relay\n * chain with the same instance of {ScClient}. The matching between relay chains and\n * parachains is done through the `relay_chain` field in the parachain specification.\n */\nexport interface ScClient {\n  /**\n   * Connects to a chain.\n   *\n   * Throws an exception if the chain specification isn't valid, or if the chain specification\n   * concerns a parachain but no corresponding relay chain can be found.\n   *\n   * Substrate-connect will automatically de-duplicate chains if multiple identical chains are\n   * added, in order to save resources. In other words, it is not a problem to call `addChain`\n   * multiple times with the same chain specifications and obtain multiple `Chain`.\n   * When the same client is used for multiple different purposes, you are in fact strongly\n   * encouraged to trust substrate-connect and not attempt to de-duplicate chains yourself, as\n   * determining whether two chains are identical is complicated and might have security\n   * implications.\n   *\n   * Substrate-connect tries to distribute CPU resources equally between all active `Chain`\n   * objects.\n   *\n   * @param chainSpec Specification of the chain to add.\n   \n   * @param jsonRpcCallback Callback invoked in response to calling {Chain.sendJsonRpc}.\n   * This field is optional. If no callback is provided, the client will save up resources by not\n   * starting the JSON-RPC endpoint, and it is forbidden to call {Chain.sendJsonRpc}.\n   * Will never be called after Ì€{Chain.remove} has been called or if a {CrashError} has been\n   * generated.\n   *\n   * @throws {AddChainError} If the chain can't be added.\n   * @throws {CrashError} If the background client has crashed.\n   */\n  addChain: AddChain\n\n  /**\n   * Connects to a chain, by its `id`.\n   *\n   * Throws an exception if no chain with this name is known.\n   *\n   * Substrate-connect will automatically de-duplicate chains if multiple identical chains are\n   * added, in order to save resources. In other words, it is not a problem to call `addChain`\n   * multiple times with the same chain specifications and obtain multiple `Chain`.\n   * When the same client is used for multiple different purposes, you are in fact strongly\n   * encouraged to trust substrate-connect and not attempt to de-duplicate chains yourself, as\n   * determining whether two chains are identical is complicated and might have security\n   * implications.\n   *\n   * Substrate-connect tries to distribute CPU resources equally between all active `Chain`\n   * objects.\n   *\n   * @param id Name of the well-known chain to add.\n   * @param jsonRpcCallback Same parameter as for {ScClient.addChain}\n   *\n   * @throws {AddChainError} If no chain with this name is known.\n   * @throws {CrashError} If the background client has crashed.\n   */\n  addWellKnownChain: AddWellKnownChain\n}\n\nexport class AlreadyDestroyedError extends Error {\n  constructor() {\n    super()\n    this.name = \"AlreadyDestroyedError\"\n  }\n}\n\nexport class CrashError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = \"CrashError\"\n  }\n}\n\nexport class JsonRpcDisabledError extends Error {\n  constructor() {\n    super()\n    this.name = \"JsonRpcDisabledError\"\n  }\n}\n"]}