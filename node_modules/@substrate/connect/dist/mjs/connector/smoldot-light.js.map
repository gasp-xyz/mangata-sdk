{"version":3,"file":"smoldot-light.js","sourceRoot":"","sources":["../../../src/connector/smoldot-light.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Chain as SChain,\n  Client,\n  ClientOptions,\n  MalformedJsonRpcError,\n  QueueFullError,\n} from \"@substrate/smoldot-light\"\nimport { getSpec } from \"./specs/index.js\"\nimport {\n  AddChain,\n  AddWellKnownChain,\n  Chain,\n  ScClient,\n  AlreadyDestroyedError,\n  CrashError,\n  JsonRpcDisabledError,\n} from \"./types.js\"\nimport { WellKnownChain } from \"../WellKnownChain.js\"\n\nlet startPromise: Promise<(options: ClientOptions) => Client> | null = null\nconst getStart = () => {\n  if (startPromise) return startPromise\n  startPromise = import(\"@substrate/smoldot-light\").then((sm) => sm.start)\n  return startPromise\n}\n\nconst clientReferences: Config[] = [] // Note that this can't be a set, as the same config is added/removed multiple times\nlet clientPromise: Promise<Client> | Client | null = null\nlet clientReferencesMaxLogLevel = 3\nconst getClientAndIncRef = (config: Config): Promise<Client> => {\n  if (config.maxLogLevel && config.maxLogLevel > clientReferencesMaxLogLevel)\n    clientReferencesMaxLogLevel = config.maxLogLevel\n\n  if (clientPromise) {\n    clientReferences.push(config)\n    if (clientPromise instanceof Promise) return clientPromise\n    else return Promise.resolve(clientPromise)\n  }\n\n  const newClientPromise = getStart().then((start) =>\n    start({\n      forbidTcp: true, // In order to avoid confusing inconsistencies between browsers and NodeJS, TCP connections are always disabled.\n      forbidNonLocalWs: true, // Prevents browsers from emitting warnings if smoldot tried to establish non-secure WebSocket connections\n      maxLogLevel: 9999999, // The actual level filtering is done in the logCallback\n      cpuRateLimit: 0.5, // Politely limit the CPU usage of the smoldot background worker.\n      logCallback: (level, target, message) => {\n        if (level > clientReferencesMaxLogLevel) return\n\n        // The first parameter of the methods of `console` has some printf-like substitution\n        // capabilities. We don't really need to use this, but not using it means that the logs\n        // might not get printed correctly if they contain `%`.\n        if (level <= 1) {\n          console.error(\"[%s] %s\", target, message)\n        } else if (level === 2) {\n          console.warn(\"[%s] %s\", target, message)\n        } else if (level === 3) {\n          console.info(\"[%s] %s\", target, message)\n        } else if (level === 4) {\n          console.debug(\"[%s] %s\", target, message)\n        } else {\n          console.trace(\"[%s] %s\", target, message)\n        }\n      },\n    }),\n  )\n\n  clientPromise = newClientPromise\n\n  newClientPromise.then((client) => {\n    // Make sure that the client we have just created is still desired\n    if (clientPromise === newClientPromise) clientPromise = client\n    else client.terminate()\n    // Note that if clientPromise != newClientPromise we know for sure that the client that we\n    // return isn't going to be used. We would rather not return a terminated client, but this\n    // isn't possible for type check reasons.\n    return client\n  })\n\n  clientReferences.push(config)\n  return clientPromise\n}\n\n// Must be passed the exact same object as was passed to {getClientAndIncRef}\nconst decRef = (config: Config) => {\n  const idx = clientReferences.indexOf(config)\n  if (idx === -1) throw new Error(\"Internal error within smoldot-light\")\n  clientReferences.splice(idx, 1)\n\n  // Update `clientReferencesMaxLogLevel`\n  // Note how it is set back to 3 if there is no reference anymore\n  clientReferencesMaxLogLevel = 3\n  for (const cfg of clientReferences.values()) {\n    if (cfg.maxLogLevel && cfg.maxLogLevel > clientReferencesMaxLogLevel)\n      clientReferencesMaxLogLevel = cfg.maxLogLevel\n  }\n\n  if (clientReferences.length === 0) {\n    if (clientPromise && !(clientPromise instanceof Promise))\n      clientPromise.terminate()\n    clientPromise = null\n  }\n}\n\nconst transformErrors = (thunk: () => void) => {\n  try {\n    thunk()\n  } catch (e) {\n    const error = e as Error | undefined\n    if (error?.name === \"JsonRpcDisabledError\") throw new JsonRpcDisabledError()\n    if (error?.name === \"CrashError\") throw new CrashError(error.message)\n    if (error?.name === \"AlreadyDestroyedError\")\n      throw new AlreadyDestroyedError()\n    throw new CrashError(\n      e instanceof Error ? e.message : `Unexpected error ${e}`,\n    )\n  }\n}\n\n/**\n * Configuration that can be passed to {createScClient}.\n */\nexport interface Config {\n  /**\n   * The client prints logs in the console. By default, only log levels 1, 2, and 3 (corresponding\n   * respectively to ERROR, WARN, and INFO) are printed.\n   *\n   * In order to more easily debug problems, you can pass 4 (DEBUG) or more.\n   *\n   * This setting is only taken into account between the moment when you use this chain to add a\n   * chain for the first time, and the moment when all the chains that you have added have been\n   * removed.\n   *\n   * If {createScClient} is called multiple times with multiple different log levels, the highest\n   * value will be used.\n   */\n  maxLogLevel?: number\n}\n\n/**\n * Returns a {ScClient} that connects to chains by executing a light client directly\n * from JavaScript.\n *\n * This is quite expensive in terms of CPU, but it is the only choice when the substrate-connect\n * extension is not installed.\n */\nexport const createScClient = (config?: Config): ScClient => {\n  const configOrDefault = config || { maxLogLevel: 3 }\n\n  const chains = new Map<Chain, SChain>()\n\n  const addChain: AddChain = async (\n    chainSpec: string,\n    jsonRpcCallback?: (msg: string) => void,\n  ): Promise<Chain> => {\n    const client = await getClientAndIncRef(configOrDefault)\n\n    try {\n      const internalChain = await client.addChain({\n        chainSpec,\n        potentialRelayChains: [...chains.values()],\n        disableJsonRpc: jsonRpcCallback === undefined,\n      })\n\n      ;(async () => {\n        while (true) {\n          let jsonRpcResponse\n          try {\n            jsonRpcResponse = await internalChain.nextJsonRpcResponse()\n          } catch (_) {\n            break\n          }\n\n          // `nextJsonRpcResponse` throws an exception if we pass `disableJsonRpc: true` in the\n          // config. We pass `disableJsonRpc: true` if `jsonRpcCallback` is undefined. Therefore,\n          // this code is never reachable if `jsonRpcCallback` is undefined.\n          try {\n            jsonRpcCallback!(jsonRpcResponse)\n          } catch (error) {\n            console.error(\"JSON-RPC callback has thrown an exception:\", error)\n          }\n        }\n      })()\n\n      const chain: Chain = {\n        sendJsonRpc: (rpc) => {\n          transformErrors(() => {\n            try {\n              internalChain.sendJsonRpc(rpc)\n            } catch (error) {\n              if (error instanceof MalformedJsonRpcError) {\n                // In order to expose the same behavior as the extension client, we silently\n                // discard malformed JSON-RPC requests.\n                return\n              } else if (error instanceof QueueFullError) {\n                // If the queue is full, we immediately send back a JSON-RPC response indicating\n                // the error.\n                try {\n                  const parsedRq = JSON.parse(rpc)\n                  jsonRpcCallback!(\n                    JSON.stringify({\n                      jsonrpc: \"v2\",\n                      id: parsedRq.id,\n                      error: {\n                        code: -32000,\n                        message: \"JSON-RPC server is too busy\",\n                      },\n                    }),\n                  )\n                } catch (_error) {\n                  // An error here counts as a malformed JSON-RPC request, which are ignored.\n                }\n              } else {\n                throw error\n              }\n            }\n          })\n        },\n        remove: () => {\n          try {\n            transformErrors(() => {\n              internalChain.remove()\n            })\n          } finally {\n            chains.delete(chain)\n            decRef(configOrDefault)\n          }\n        },\n      }\n\n      chains.set(chain, internalChain)\n      return chain\n    } catch (error) {\n      decRef(configOrDefault)\n      throw error\n    }\n  }\n\n  const addWellKnownChain: AddWellKnownChain = async (\n    supposedChain: WellKnownChain,\n    jsonRpcCallback?: (msg: string) => void,\n  ): Promise<Chain> => {\n    // the following line ensures that the http request for the dynamic import\n    // of smoldot-light and the request for the dynamic import of the spec\n    // happen in parallel\n    getClientAndIncRef(configOrDefault)\n\n    try {\n      const spec = await getSpec(supposedChain)\n      return await addChain(spec, jsonRpcCallback)\n    } finally {\n      decRef(configOrDefault)\n    }\n  }\n  return { addChain, addWellKnownChain }\n}\n"]}