{"version":3,"file":"extension.js","sourceRoot":"","sources":["../../../src/connector/extension.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ToApplication,\n  ToExtension,\n} from \"@substrate/connect-extension-protocol\"\nimport {\n  AlreadyDestroyedError,\n  CrashError,\n  JsonRpcDisabledError,\n  Chain,\n  JsonRpcCallback,\n  ScClient,\n} from \"./types.js\"\nimport { WellKnownChain } from \"../WellKnownChain.js\"\nimport { getSpec } from \"./specs/index.js\"\n\nconst listeners = new Map<string, (msg: ToApplication) => void>()\nif (typeof window === \"object\") {\n  window.addEventListener(\n    \"message\",\n    ({ data }: MessageEvent<ToApplication>) => {\n      if (data?.origin !== \"substrate-connect-extension\") return\n      listeners.get(data.chainId)?.(data)\n    },\n  )\n}\n\nfunction getRandomChainId(): string {\n  const arr = new BigUint64Array(2)\n  // It can only be used from the browser, so this is fine.\n  crypto.getRandomValues(arr)\n  const result = (arr[1] << BigInt(64)) | arr[0]\n  return result.toString(36)\n}\n\n/**\n * Returns a {@link ScClient} that connects to chains by asking the substrate-connect extension\n * to do so.\n *\n * This function assumes that the extension is installed and available. It is out of scope of this\n * function to detect whether this is the case.\n * If you try to add a chain without the extension installed, nothing will happen and the\n * `Promise`s will never resolve.\n */\nexport const createScClient = (): ScClient => {\n  const chains = new Map<Chain, string>()\n\n  const internalAddChain = async (\n    isWellKnown: boolean,\n    chainSpecOrWellKnownName: string,\n    jsonRpcCallback?: JsonRpcCallback,\n    potentialRelayChainIds = [] as string[],\n  ): Promise<Chain> => {\n    type ChainState =\n      | {\n          state: \"pending\"\n          waitFinished: () => void\n        }\n      | {\n          state: \"ok\"\n        }\n      | { state: \"dead\"; error: AlreadyDestroyedError | CrashError }\n\n    let resolve: undefined | (() => void)\n    const initFinished = new Promise((res) => {\n      resolve = () => res(null)\n    })\n    const chainState: { id: string; state: ChainState } = {\n      id: getRandomChainId(),\n      state: {\n        state: \"pending\",\n        waitFinished: resolve!,\n      },\n    }\n\n    if (listeners.has(chainState.id))\n      throw new Error(\n        \"Unexpectedly randomly generated the same chain ID twice despite 64bits of entropy\",\n      )\n\n    // Setup the listener for this chain.\n    // This listener should never be removed until we are no longer interested in this chain.\n    // Removing then re-adding the listener could cause messages to be missed.\n    listeners.set(chainState.id, (msg) => {\n      switch (chainState.state.state) {\n        case \"pending\": {\n          const waitFinished = chainState.state.waitFinished\n          switch (msg.type) {\n            case \"chain-ready\": {\n              chainState.state = {\n                state: \"ok\",\n              }\n              break\n            }\n            case \"error\": {\n              chainState.state = {\n                state: \"dead\",\n                error: new CrashError(\n                  \"Error while creating the chain: \" + msg.errorMessage,\n                ),\n              }\n              break\n            }\n            default: {\n              // Unexpected message. We ignore it.\n              // While it could be tempting to switch the chain to `dead`, the extension might\n              // think that the chain is still alive, and the state mismatch could have\n              // unpredictable and confusing consequences.\n              console.warn(\n                \"Unexpected message of type `msg.type` received from substrate-connect extension\",\n              )\n            }\n          }\n          waitFinished()\n          break\n        }\n        case \"ok\": {\n          switch (msg.type) {\n            case \"error\": {\n              chainState.state = {\n                state: \"dead\",\n                error: new CrashError(\n                  \"Extension has killed the chain: \" + msg.errorMessage,\n                ),\n              }\n              break\n            }\n            case \"rpc\": {\n              if (jsonRpcCallback) {\n                jsonRpcCallback(msg.jsonRpcMessage)\n              } else {\n                console.warn(\n                  \"Unexpected message of type `msg.type` received from substrate-connect extension\",\n                )\n              }\n              break\n            }\n            default: {\n              // Unexpected message. We ignore it.\n              // While it could be tempting to switch the chain to `dead`, the extension might\n              // think that the chain is still alive, and the state mismatch could have\n              // unpredictable and confusing consequences.\n              console.warn(\n                \"Unexpected message of type `msg.type` received from substrate-connect extension\",\n              )\n            }\n          }\n          break\n        }\n        case \"dead\": {\n          // We don't expect any message anymore.\n          break\n        }\n      }\n    })\n\n    // Now that everything is ready to receive messages back from the extension, send the\n    // add-chain message.\n    if (isWellKnown) {\n      postToExtension({\n        origin: \"substrate-connect-client\",\n        chainId: chainState.id,\n        type: \"add-well-known-chain\",\n        chainName: chainSpecOrWellKnownName,\n      })\n    } else {\n      postToExtension({\n        origin: \"substrate-connect-client\",\n        chainId: chainState.id,\n        type: \"add-chain\",\n        chainSpec: chainSpecOrWellKnownName,\n        potentialRelayChainIds,\n      })\n    }\n\n    // Wait for the extension to send back either a confirmation or an error.\n    // Note that `initFinished` becomes ready when `chainState` has been modified. The outcome\n    // can be known by looking into `chainState`.\n    await initFinished\n\n    // In the situation where we tried to create a well-known chain, the extension isn't supposed\n    // to ever return an error. There is however one situation where errors can happen: if the\n    // extension doesn't recognize the desired well-known chain because it uses a different list\n    // of well-known chains than this code. To handle this, we download the chain spec of the\n    // desired well-known chain and try again but this time as a non-well-known chain.\n    if (isWellKnown && chainState.state.state === \"dead\") {\n      // Note that we keep the same id for the chain for convenience.\n      let resolve: undefined | (() => void)\n      const initFinished = new Promise((res) => {\n        resolve = () => res(null)\n      })\n      chainState.state = {\n        state: \"pending\",\n        waitFinished: resolve!,\n      }\n\n      postToExtension({\n        origin: \"substrate-connect-client\",\n        chainId: chainState.id,\n        type: \"add-chain\",\n        chainSpec: await getSpec(chainSpecOrWellKnownName),\n        potentialRelayChainIds: [],\n      })\n\n      await initFinished\n    }\n\n    // Now check the `chainState` to know if things have succeeded.\n    if (chainState.state.state === \"dead\") {\n      throw chainState.state.error\n    }\n\n    // Everything is successful.\n    const chain: Chain = {\n      sendJsonRpc: (jsonRpcMessage) => {\n        if (chainState.state.state === \"dead\") {\n          throw chainState.state.error\n        }\n\n        if (!jsonRpcCallback) throw new JsonRpcDisabledError()\n        postToExtension({\n          origin: \"substrate-connect-client\",\n          chainId: chainState.id,\n          type: \"rpc\",\n          jsonRpcMessage,\n        })\n      },\n      remove: () => {\n        if (chainState.state.state === \"dead\") {\n          throw chainState.state.error\n        }\n\n        chainState.state = {\n          state: \"dead\",\n          error: new AlreadyDestroyedError(),\n        }\n\n        listeners.delete(chainState.id)\n        chains.delete(chain)\n\n        postToExtension({\n          origin: \"substrate-connect-client\",\n          chainId: chainState.id,\n          type: \"remove-chain\",\n        })\n      },\n    }\n\n    // This mapping of chains is kept just for the `potentialRelayChainIds` field.\n    chains.set(chain, chainState.id)\n\n    return chain\n  }\n\n  return {\n    addChain: (chainSpec: string, jsonRpcCallback?: JsonRpcCallback) =>\n      internalAddChain(false, chainSpec, jsonRpcCallback, [...chains.values()]),\n    addWellKnownChain: (\n      name: WellKnownChain,\n      jsonRpcCallback?: JsonRpcCallback,\n    ) => internalAddChain(true, name, jsonRpcCallback),\n  }\n}\n\n// Sends a message to the extension. This function primarly exists in order to provide strong\n// typing for the message.\nfunction postToExtension(msg: ToExtension) {\n  window.postMessage(msg, \"*\")\n}\n"]}