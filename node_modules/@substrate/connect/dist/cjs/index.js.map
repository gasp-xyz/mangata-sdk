{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmFG;;;;;;;;;;;;;;;;;AAEH,yDAAoD;AAA3C,mHAAA,cAAc,OAAA;AACvB,uDAAoC","sourcesContent":["/**\n * The substrate-connect package makes it possible to connect to Substrate-compatible blockchains with a light client.\n *\n * Connecting to a chain is done in two steps:\n *\n * 1. Call {@link createScClient}, which gives you a so-called *client*.\n * 2. Call {@link addChain} or {@link addWellKnownChain} on this client.\n *\n * Note that this library is a low-level library where you directly send JSON-RPC requests and\n * receive responses.\n * For a high-level library build on top of `substrate-connect` you can use\n * {@link https://github.com/polkadot-js/api/tree/master/packages/rpc-provider | polkadot/rpc-provider/substrate-connect}\n *\n * # Adding parachains\n *\n * Connecting to a parachain is done the same way as connecting to a standalone chain: obtaining\n * a client then calling {@link addChain}.\n *\n * However, if you call {@link addChain} with a parachain chain specification, you **must** have\n * connected to its corresponding relay chain beforehand (using {@link addChain} or {@link addWellKnownChain}).\n * Failing to do so will lead to an error at the initialization of the parachain.\n *\n * Furthermore, the parachain must be added to the same client object as the one the relay chain\n * was added to.\n *\n * In other words, this will work:\n *\n * ```js\n * const client = createScClient();\n * await client.addChain(relayChain);\n * await client.addChain(parachain);\n * ```\n *\n * While this will **not** work, and an exception will be thrown when adding the parachain:\n *\n * ```js\n * await createScClient().addChain(relayChain);\n * await createScClient().addChain(parachain);\n * ```\n *\n * # Resources sharing\n *\n * While calling {@link createScClient} multiple times leads to a different observable behaviour\n * when it comes to parachains (see previous section), internally resources are shared\n * between all the clients.\n *\n * In order words, it is not a problem to do this:\n *\n * ```js\n * const relayChain = ...;\n * const chain1 = await createScClient().addChain(relayChain);\n * const chain2 = await createScClient().addChain(relayChain);\n * ```\n *\n * From an API perspective, `chain1` and `chain2` should be treated as two completely separate\n * connections to the same chain. Internally, however, only one \"actual\" connection to that chain\n * will exist.\n *\n * This means that there is no problem in calling {@link createScClient} from within a library for\n * example.\n *\n * # Well-known chains\n *\n * This package contains a list of so-called {@link WellKnownChain}s. This is a list of popular chains\n * that users are likely to connect to. Instead of calling `addChain` with a chain specification,\n * one can call `addWellKnownChain`, passing only the name of a well-known chain as parameter.\n *\n * Using {@link WellKnownChain}s doesn't provide any benefit when the substrate-connect extension is not\n * installed.\n *\n * If, however, the substrate-connect extension is installed, using {@link addWellKnownChain} has several\n * benefits:\n *\n * - The web page that uses substrate-connect doesn't need to download the chain specification of\n * a well-known chain from the web server, as this chain specification is already known by the\n * extension.\n * - The extension starts connect to well-known chains when the browser initializes, meaning that\n * when {@link addWellKnownChain} is called, it is likely that the chain in question has already been\n * fully synchronized.\n * - Furthermore, the extension stores the state of all the well-known chains in the browser's\n * local storage. This leads to a very quick initialization time.\n *\n * @packageDocumentation\n */\n\nexport { WellKnownChain } from \"./WellKnownChain.js\"\nexport * from \"./connector/index.js\"\n"]}